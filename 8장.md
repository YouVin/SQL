# 데이터베이스 설계

### ⭐️데이터베이스 설계

데이터베이스를 설계한다는 것은 데이터베이스의 스키마 내에 테이블, 인덱스, 뷰 등의 데이터베이스 객체를 정의하는 것을 말합니다. 스키마 내에 정의한다는 뜻에서 ‘스키마 설계’라 불리기도 합니다.

데이터베이스 설계의 주된 내용은 테이블의 이름이나 열, 자료형을 결정하는 것 입니다. ‘이 테이블은 이 열을 이용해 저쪽 테이블과 연결한다’와 같이 테이블 간의 관계를 생각하면서 여러 테이블을 정의하고 작성하게 됩니다.

- 논리명과 물리명

테이블을 설계할 때는 테이블 정의서나 설계도 등의 문서를 작성하는 경우가 많습니다. 

테이블을 설계할 때는 테이블 이름이나 열 이름을 지정하는데, 하나의 테이블에 대해 두 개의 이름을 지정할 때도 있습니다. 하나는 데이터베이스에서 사용될 이름으로, 실제로는 CREATE TABLE에 지정하는 이름을 말하며 ‘물리명’이라 부릅니다. 또 하나는 ‘논리명’이라는 것으로 테이블의 ‘설계상 이름’에 해당합니다.

물리명은 데이터베이스 시스템 규칙에 따라 길이에 제한이 있거나 공백문자를 사용할 수 없는 등의 제약이 따릅니다. 따라서 일상에서 사용하는 단어로는 이름을 지정하는 데 한계가 있습니다. 또한 전통적으로 알파벳을 사용해 이름을 지정합니다.

길이도 제한되다 보니 생략하거나 약자로 이름을 붙이는 경우도 많습니다. 그러다 보면 물리명만으로는 의미가 전달되지 않는 경우도 많아 논리명이 필요해집니다. 여기서 차이점은, 물리명의 경우 CREATE TABLE 명령으로 테이블을 작성할 때 사용하는 이름이라면, 논리명은 해당 테이블을 실제로 부를 때 사용하는 이름이라는 점입니다.

물리명은 잘못 정하면 변경하기 힘들지만 논리명은 언제나 바꿀 수 있습니다.

- 자료형

테이블의 열에는 자료형을 지정해야 합니다. 
데이터베이스에 따라 다르지만 무엇이든 저장할 수 있는 자료형은 없습니다. 수치 데이터만 저장하는 열에는 설계 시수치형으로 지정합니다. 따라서 금액이나 개수처럼 수치 데이터만 다룰 수 있는 열은 주저없이 수치 자료형으로 지정하면 됩니다. 한편 제조번호처럼 알파벳도 다루어야 한다면 문자열형으로 지정하는 편이 낫습니다. 

수치형을 문자열형을 변환하는 것은 문제가 되지 않지만 문자열형을 수치형으로 변환하는 경우에는 에러가 발생하기도 해 번거로울 수 있습니다.

데이터에 따라서는 ‘1, 2, 3 중에 하나’ 라든가 ‘YES, NO’ 중에 하나 만 데이터 값으로 취급하는 경우가 생기기도 합니다. 이런 경우에는 데이터베이스 기능으로 제약(CHECK)을 걸 수 있으므로 데이터 정합성이 중요한 부분에는 적극적으로 사용해야 합니다.

일반적으로는, 데이터베이스 시스템에서 데이터 정합성을 체크할 수 있다면 데이터베이스에 맡겨버리는 편이 가장 확실하고 편리합니다. 이런 기능을 활용하는 대신 애플리케이션에서 따로 구현해 사용할 수도 있지만, 이런 경우 정합성이 맞지 않을 수 있으며 개발비용도 상승해 추천하고 싶지 않습니다.

- 고정길이와 가변길이

문자열의 자료형에는 고정길이와 가변길이가 있습니다. 어느 쪽으로 지정할 것 인지는 저장할 데이터를 고려해 결정합니다. 예를 들어 제조번호 처럼 자리수가 이미 정해져 있는 경우에는 고정길이 문자열로 지정하는 편이 좋습니다. 데이터의 최대길이 역시 제조번호의 자릿수에 맞춰 정하면 됩니다. 한편, 비고란과 같이 자주 입력되지도 않지만 입력되는 문자열의 길이의 변동폭이 클 경우에는 가변길이 문자열이 적합합니다.

데이터베이스의 열에 저장할 수 있는 크기는 의외로 작습니다. VARCHAR형으로 지정할 수 있는 최대 크기는 기껏해야 수천 바이트입니다. 조금 큰 파일을 그대로 VARCHAR 형의 열에 저장하면 쉽게 용량을 넘겨버립니다. 이럴 경우에는 LOB 형을 사용합니다. 

여기서 LOB(Large Object)의 약자입니다. LOB형은 큰 데이터를 다루는 자료형이지만 인덱스를 지정할 수 없다는 제약이 있습니다.

- 기본키

테이블을 작성할 때 기본키 제약을 거는 경우에는 주의를 기울여야 합니다. 테이블의 행에 유일성을 지정한다는 것은 대단히 중요한 일입니다. 하지만 기본키로 지정할 열이 생각나지 않는 경우도 많을 것입니다. 이러한 경우 자동증가 열을 사용해서 기본키로 지정합니다.

자동증가 열은 INSERT할 경우 번호를 자동으로 증가 시켜 저장해주는 편리한 열입니다. 데이터베이스 제품에 따라 다르지만, MySQL의 경우는 열을 정의할 때 AUTO_INCREMENT를 지정하는 것으로 자동증가 열이 됩니다. 

AUTO_INCREMENT로 지정한 열은 PRIMARY KEY 또는 UNIQUE로 유일성을 지정해야 합니다. 이외에도 테이블 설계에 관련해 정규화라는 것도 있습니다.

### ⭐️ER다이어그램

테이블을 설계할 때 테이블 간의 관계를 명확히 하기 위해 설계도를 작성하는 겨우가 있습니다. ER다이어그램은 이런 경우에 널리 쓰이는 도식입니다.

ER의 E는 개체를 뜻하는 ‘Entity’의 약자이며 R은 ‘Relationship’의 약자입니다. 즉, ER다이어그램은 개체 간의 관계를 표현한 것입니다. 여기에서도 관계라는 단어가 나옵니다만 ER다이어그램의 관계는 관계형 데이터베이스의 릴레이션과 달리 릴레이션십을 가리킵니다.

엔티티, 즉 개체는 테이블 또는 뷰를 말합니다. ER다이어그램에서 개체는 사각형으로 표기합니다. 사각형의 상단에는 개체 이름을 적고 사각형 안에는 개체의 속성을 표기합니다. 여기서 속성은 테이블의 열을 의미합니다. 기본키가 되는 열부터 차례로 기술하며, 열 이름은 주로 논리명으로 표기합니다.

개체와 개체가 서로 연계되는 경우에는 선으로 이어서 표현합니다. 앞에서 결합을 설명할 때 작성했던 상품 테이블과 메이커 테이블은 메이커코드를 매체로 연결됩니다. 

연계를 표기할 때는 서로 몇 개의 데이터 행과 연관되는지, 즉 몇 대 몇의 관계를 가지는지를  숫자나 기호로 나타낼 수 있습니다. 
여러 가지 패턴의 표기방법 중에서도 가장 기본이 되는 세가지는 다음과 같습니다.

- 일대일
- 일대다
- 다대다

ER다이어그램의 연계는 데이터베이스에서는 외부참조제약으로 지정되는 경우가 있으므로 기억해두세요. 외부키 제약을 설정하면 데이터의 정합성이 엄격히 관리되어 번거로워진다는 이유로 이를 채용하지 않는시스템도 있습니다. ‘설계상 이렇게 연관되어 있다’라고 나타내는 것이 ER다이어그램의 역할입니다.

# 정규화

정규화란 데이터베이스의 테이블을 규정된 올바른 형태로 개선해나가는 것입니다. 정규화는 데이터베이스의 설계 단계에서 행해집니다. 경우에 따라서는 기존 시스템을 재검토할 때 정규화하는 경우도 있습니다.

여기서 말하는 올바른 형태란 주관적 기준이라 할 수 있습니다. 정규화의 순서는 이전의 데이터베이스 기술자들이 고안해 정리한 것입니다. 

### ⭐️정규화

예제를 통해 정규화해 나가겠습니다.

| 주문번호 | 날짜 | 성명 | 연락처 | 주문상품 |
| --- | --- | --- | --- | --- |
| 1 | 1/1 | 박준용 | 010-xxxx | 0001OO 1개, 0002 XX 10개 |
| 2 | 2/1 | 김재진 | 010-XXXX | 0001OO 2개, 0002 XX 3개 |
| 3 | 2/5 | 박준용 | 010-XXXX | 0001OO 3개, 0003 ㅁㅁ 1개 |

0001 상품과 0002 상품 0003 상품 3개가 있습니다. 

정규화는 단계적으로 실시합니다. 그 첫 번째 단계가 제1 정규화로, 이를 시행하면 제1 정규형 테이블을 만들 수 있습니다.

### ⭐️제1정규형

관계형 데이터베이스의 테이블에는 하나의 셀에 하나의 값만 저장할 수 있다는 제약이 있습니다. 이로 인해 주문상품의 데이터를 그대로 테이블로 만들 수는 없습니다. 적어도 상품코드와 상품명, 개수 데이터를 담는 세 개의 열로 나누어야 합니다.

위에 표에서 주문상품 데이터를 상품코드, 상품명, 개수로 분할한다.

| 상품코드 | 상품명 | 개수 |
| --- | --- | --- |
| 0001 | OO | 1 |
| 0002 | XX | 1 |
| 0003 | ㅁㅁ | 3 |

위와 같이 주문상품을 붆할함에 따라 열이 두 개 더 추가되었고 행도 늘어난 것에 주목하면 됩니다. 하나의 셀에 하나의 값만 저장할 수 있도록 하고, 반복되는 부분을 세로 방향으로 늘려나가는 것이 제1 정규화의 제1단계입니다.

제1정규화에서는 중복을 제거하는 테이블의 분할도 이루어집니다.

먼저 주문 테이블을 주문상품 테이블과 주문 테이블로 나눕니다. 주문 테이블은 주문번호, 날짜, 성명, 연락처로 구성됩니다. 한편 주문상품 테이블은 상품코드, 상품명, 개수로 구성하되, 추가적으로 주문 테이블과 결합할 수 있도록 주문번호 열을 추가합니다.

| 주문번호 | 상품코드 | 상품명 | 개수 |
| --- | --- | --- | --- |
| 1 | 0001 | OO | 1 |
| 2 | 0002 | XX | 1 |
| 3 | 0003 | ㅁㅁ | 3 |

위와 같이 주문 번호로 연계하여 사용합니다.

여기에서 분할 이후의 주문 테이블을 자세히 살펴보면, 주문번호에는 중복된 값이 존재하지 않기 때문에 기본키로 지정할 수 있습니다. 한편 주문상품 테이블에서는 주문 번호와 상품코드를 한데 묶어 기본키로 지정할 수 있습니다.

### ⭐️제2정규형

제2정규화에서는 데이터가 중복하는 부분을 찾아내어 테이블로 분할해 나갑니다. 이때 기본키에 의해 특정되는 열과 그렇지 않은 열로 나누는 것으로 정규화가 이루어집니다. 

주문상품의 기본키는 주문번호와 상품코드의 두 개 열로 되어 있습니다. 주문번호 1에 상품코드가 0001인 상품 주문량은 총 1개라는 것을 알 수 있습니다. 이것은 기본키를 바탕으로 특정되는 데이터입니다. 즉, 개수 열은 기본키가 결정되고 나면 특정할 수 있는 것입니다.

따라서 주문 상품 테이블을 분할합니다.

주문상품

| 주문번호 | 상품코드 | 개수 |
| --- | --- | --- |
| 1 | 0001 | 1 |
| 1 | 0002 | 10 |
| 2 | 0001 | 2 |
| 2 | 0002 | 3 |
| 3 | 0001 | 3 |
| 3 | 0003 | 1 |

상품

| 상품코드 | 상품명 |
| --- | --- |
| 0001 | OO |
| 0002 | XX |
| 0003 | ㅁㅁ |

상품테이블은 상품코드만으로 기본키를 지정했습니다. 부분 함수종속성을 찾아내서 테이블을 분할하는 것이 제2정규화입니다. 여기서 함수종속성이란 키 값을 이용해 데이터를 특정지을 수 있는 것을 가리킵니다.

### ⭐️제3정규형

제3정규형은 중복하는 부분을 찾아내어 테이블을 분할하는 수법입니다. 제2정규화의 경우에는 기본키에 중복이 없는지 조사했습니다.만 제3정규화에서는 기본키 이외의 부분에서 중복이 없는지를 조사합니다.

주문 테이블을 분할합니다.

주문

| 주문번호 | 날짜  | 고객번호 |
| --- | --- | --- |
| 1 | 1/1 | 1 |
| 2 | 2/1 | 2 |
| 3 | 2/5 | 1 |

고객

| 고객번호 | 성명 | 연락처 |
| --- | --- | --- |
| 1 | 박준용 | 010-XXXX |
| 2 | 김재진 | 016-XXXX |

분할하기 전에 주문 테이블을 살펴보면 데이터가 중복되어 있습니다. 같은 사람이 여러 번 주문하는 경우가 있기 때문입니다. 이때 주문 테이블에서 이름을 기준으로 연락처를 특정지을 수 있습니다. 단, 주문 테이블의 기본키는 어디까지나 주문번호로, 이름은 기본키와는 관계 없습니다.

실제로는 제 5정규형까지 있지만 대부분의 시스템에서는 제3정규형까지의 채택합니다.

위처럼 총 4개의 테이블로 분할된 테이블 간의 연계를 ER다이어그램으로 표현하여 표기합니다. 

### ⭐️정규화의 목적

정규화에서는 중복하거나 반복되는 부분을 찾아내서 테이블을 분할하고 기본키를 작성해 사용하는 것을 기본 개념으로 삼습니다. 이는 ‘하나의 데이터는 한곳에 있어야 한다’는 규칙에 근거합니다.

하나의 데이터가 반드시 한 곳에만 저장되어 있다면 데이터를 변경하더라도 한 곳만 변경하는 것으로 끝낼 수 있습니다. 반면 정규화 되지 않은 경우에는 여기저기 중복해서 저장된 데이터를 검색하고 일일히 변경해야 합니다. 이것은 매우 번거로운 작업입니다. 또한 인덱스가 지정된 열의 데이터가 변경되는 경우에는 인덱스도 재구축해야 합니다.

# 트랜잭션

```sql
- 트랜잭션의 제어
START TRANSACTION
COMMIT
ROLLBACK
```

데이터베이스는 트랜잭션이라는 기능을 제공합니다. INSERT나 UPDATE 명령으로 데이터를 추가, 갱신할 때도 트랜잭션 기능을 사용합니다만 지금까지 특별히 의식할 필요는 업성ㅆ습니다. 이는 자동 커밋이라는 기능이 동작했기 때문입니다.

### ⭐️트랜잭션

위에 주문 테이블과 주문상품 테이블의 관계로 생각해보겠습니다.

주문 테이블과 주문상품 테이블 사이에는 의존관계가 존재합니다. 
주문 테이블에 행이 존재한다면 주문상품 테이블에는 적어도 하나의 행이 존재해야 합니다. 그렇지 않으면 주문한 상품이 없는데도 주문이 된 상태가 됩니다. 보통은 하나 이상의 상품을 주문하므로 주문이 발생하면 주문 테이블과 주문상품 테이블 모두 행이 추가됩니다.

- 발주처리

주문이 발생했을 때 어떻게 처리되는지 생각해봅시다. 간단히 말하자면 발주처리에 관한 것으로, 먼저 주문번호를 지정해야 합니다. 이때 기존 주문과 구분되는 주문번호를 발행하는 처리가 필요합니다.

자동 증가를 사용하면 자동적으로 번호가 부여됩니다만 그렇지 않은 경우에는 ‘번호 중 가장 큰 값을 SELECT 명령으로 가져와 그 값에 1을 더한다’ 라는 처리가 필요합니다. 최대값은 MAX()로 검색할 수 있으므로 ‘MAX + 1’이라 할 수 도 있습니다.

번호를 발행 받았다면 해당 번호를 키를 삼아 INSERT가 이루어 집니다. 주문 테이블에는 INSERT 한 번, 주문상품 테이블에는 주문된 상품 수만큼 INSERT 명령이 실행됩니다. 중요한 것은 복수의 테이블에 INSERT 되므로 실행되는 명령은 최소 두 번이라는 것입니다.

```sql
- 발주처리
INSERT INTO 주문 VALUES(4, '2014-03-01', 1);
INSERT INTO 주문상품 VALUES(4, '0003', 1);
INSERT INTO 주문상품 VALUES(4, '0004', 2);
```

여기서 INSERT 명령이 특정 원인으로 인해 에러가 발생한 경우를 가정해봅시다. 트랜잭션 기능을 사용하지 않을 때는 문제없이 실행된 INSERT 명령을 실행 전으로 되돌릴 수 없으므로 따로 DELETE 명령을 실행해 지워야합니다. 즉, 위에 발주 처리에서 3번째 코드 INSERT명령에서 에러가 발생했다고 치면, 앞서 실행한 두 개의 INSERT 명령에 의해 추가된 데이터를 DELETE 명령으로 삭제하는 처리가 필요합니다.

### ⭐️롤백과 커밋

이처럼 몇 단계로 처리를 나누어 SQL 명령을 실행하는 경우에 트랜잭션을 자주 사용합니다. 트랜잭션을 사용해서 데이터를 추가한다면 에러가 발생해도 트랜잭션을 롤백(ROLLBACK)해서 종룔할 수 있습니다. 롤백하면 트랜잭션 내에서 행해진 모든 변경사항을 없었던 것으로 할 수 있습니다. 아무런 에러가 발생하지 않는다면 변경사항을 적용하고 트랜잭션을 종료하는데, 이때 커밋(COMMIT)을 사용합니다.

- 자동커밋

트랜잭션을 사용해서 데이터를 추가할 때는 자동커밋을 꺼야 합니다. mysql 클라이언트에서 명령을 실행할 때는 자동커밋이 켜져 있는 상태입니다. INSERT 나 UPDATE, DELETE가 처리될 때마다 트랜잭션은 암묵적으로 자동커밋 상태로 되어 있습니다. 자동커밋을 끄기 위해서는 명시적으로 트랜잭션의 시작을 선언할 필요가 있습니다. 트랜잭션을 시작할 때는 START TRANSACTION 명령을 사용합니다.

```sql
-트랜잭션 시작
START TRANSACTION
```

트랜잭션을 종료하기 위해서는 변경된 내용을 적용한 뒤에 종료하는 ‘커밋’과 적용하지 않고 종료하는 ‘롤백’의 두 가지 방식이 있습니다.
커밋할 때는 COMMIT 명령을 사용합니다.

```sql
- 트랜잭션 내에서 실행한 명령을 적용한 후 종료
COMMIT
```

롤백은 ROLLBACK 명령을 사용합니다.

```sql
- 트랜잭션 내에서 실행한 명령을 파기한 후 종료
ROLLBACK
```

트랜잭션 내에서 실행된 SQL 명령은 임시 데이터 영역에서 수행되다가, COMMIT 명령을 내리면 임시 데이터 영역에서 정식 데이터 영역으로 변경이 적용된다.이후 ROLLBACK 명령으로 임시 데이터 영역에서의 처리는 버려집니다.

```sql
- 트랜잭션 내에서 발주처리
START TRANSACTION
INSERT INTO 주문 VALUES(4, '2014-03-01', 1);
INSERT INTO 주문상품 VALUES(4, '0003', 1);
INSERT INTO 주문상품 VALUES(4, '0004', 2);
COMMIT;
```

이렇게 트랜잭션을 시작해서 SQL 명령을 실행하고 COMMIT 또는 ROLLBACK명령으로 트랜잭션을 종료하는 일련의 처리방법을 ‘트랜잭션을 걸어서 실행한다’ 또는 ‘트랜잭션 내에서 실행한다’말합니다.

### ⭐️트랜잭션 사용법

발주처리와 같은 데이터 등록처리 과정에서는 대부분 트랜잭션 내에서 여러 개의 SQL 명령을 실행하게 됩니다. 다만 하나의 명령에 트랜잭션을 걸어 실행하는 것은 별로 의미가 없습니다.

트랜잭션을 시작할 때 사용하는 명령은 ‘START TRANSACTION’이라고 설명했습니다만 이것은 MySQL의 경우에 적용됩니다. 

자동커밋은 클라이언트 툴의 기능입니다. 미들웨어도 데이터베이스 접속 시 대게 자동커밋을 합니다. 한편, 데이터베이스 서버에서는 언제나 트랜잭션을 걸 수 있는 상태로 SQL 명령이 실행됩니다. 트랜잭션을 사용할 경우에는 접속형태나 클라이언트 툴의 자동커밋 사용 여부 등 트랜잭션 관련 기능을 파악해야 합니다.