# 데이터베이스 객체

### ⭐️ 데이터베이스 객체

데이터베이스 객체란 테이블이나 뷰, 인덱스 등 데이터베이스 내에 정의하는 모든 것을 일컫는 말입니다. 단순히 객체라고 하면 C++ 이나 자바에서 사용하는 객체지향 프로그래밍의 ‘객체’와 혼돈하는 경향이 있는데, 데이터베이스 내의 객체라는 의미로 ‘데이터베이스 객체’라 부릅니다.

객체는 데이터베이스 내에 실체를 가지는 어떤 것을 말합니다. 객체의 종류에 따라 데이터베이스에 저장되는 내용도 달라집니다. 지금까지 학습한 것 중에 객체에 해당하는 것은 테이블입니다. 테이블의 경우 행과 열이 저장됩니다.

객체는 이름을 가집니다. 데이터베이스 내에서 객체를 작성할 때는 이름이 겹치지 않도록 합니다. 객체 이외에도 테이블의 열 또한 이름을 가집니다. 

이름을 붙일 때는 다음과 같은 제약 사항을 따릅니다.

- 기존 이름이나 예약어와 중복하지 않는다.
- 숫자로 시작할 수 없다.
- 언더스코어(__) 이외의 기호는 사용할 수 없다.
- 한글을 사용할 때는 더블쿼트(MySQL 에서는 백쿼트)로 둘러싼다.
- 시스템이 허용하는 길이를 초과하지 않는다.

이름은 객체의 종류와는 관계없다는 것에 주의합니다.

### ⭐️스키마

데이터베이스 객체는 스키마라는 그릇 안에 만들어집니다. 따라서 객체의 이름이 같아도 스키마가 서로 다르다면 상관없습니다.

이와 같은 특징 때문에 데이터베이스 객체는 ‘스키마 객체’라 불리기도 합니다. 실제로 데이터베이스에 테이블을 작성해서 구축해나가는 작업을 ‘스키마 설계’라고 부릅니다. 이때 스키마는 SQL 명령의 DDL을 이용하여 정의합니다.

MySQL에서는 CREATE DATABASE 명령으로 작성한 ‘데이터베이스’가 스키마가 됩니다. 

테이블과 스키마는 무엇인가를 담는 그릇 역할을 한다는 점에서 비슷합니다. 테이블 안에는 열을 정의할 수 있고 스키마 안에는 테이블을 정의할 수 있습니다. 각각의 그릇 안에서는 중복하지 않도록 이름을 지정합니다. 이처럼 이름이 충돌하지 않도록 기능하는 그릇을 ‘네임스페이스(namespace)’ 라고 부르기도 합니다. 

# 테이블 작성, 삭제, 변경

```sql
- 테이블의 작성, 삭제, 변경
CREATE TABLE 테이블명
DROP TABLE 테이블명
ALTER TABLE 테이블명 하부 명령
```

### ⭐️테이블 작성

DDL은 모두 같은 문법을 사용합니다.

CREATE로 작성, DROP으로 삭제, ALTER로 변경할 수 있습니다.

RDBMS에서 데이터베이스 상에 제일 먼저 만드는 것 객체 중 하나가 바로 테이블 입니다. CREATE TABLE 명령을 사용합니다. 테이블 명 뒤에서는 괄호로 묶어 열을 정의할 수 있습니다. 열을 정의할 때는 테이블에 필요한 열을 콤마( , )로 구분하여 연속해 지정합니다.

```sql
CREATE TABLE 테이블명 ( 
	열 정의1,
	열 정의2,
	...
)
```

열명은 열에 붙이는 이름으로 명명 규칙에 맞게 이름을 붙여줍니다. 자료형은 INTEGER나 VARCHAR 등을 지정합니다. 문자열형으로 지정할 때는 최대길이를 괄호로 묶어줘야 합니다.

기본값을 설정할 때는 DEFAULT로 지정하되 자료형에 맞는 리터럴로 기술합니다 또한, 기본값은 생략할 수 있습니다.

마지막으로 열이 NULL을 허용할 것인지를 지정합니다. NULL을 명시적으로 지정하거나 생략했을 경우는 NULL을 허용합니다. 한편 NOT NULL이라고 지정하면 제약이 걸리면서 NULL이 허용되지 않습니다.

```sql
- 열 정의
열명 자료형 [DEFAULT 기본값] [NULL|NOT NULL]
```

다음 sample62 테이블을 확인해 봅시다.

```sql
- CREATE TABLE로 테이블 작성하기
mysql> CREATE TABLE sample62 ( 
	no INTEGER NOT NULL, 
	a VARCHAR(30), 
	b DATE);

mysql> DESC sample62;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| no    | int         | NO   |     | NULL    |       |
| a     | varchar(30) | YES  |     | NULL    |       |
| b     | date        | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
```

### ⭐️테이블 삭제

테이블을 삭제할 때는 DROP TABLE 명령을 사용합니다.

DROP TABLE에서 지정하는 것은 테이블명 뿐입니다. 이때 주의할 점은 많은 데이터베이스가 SQL 명령을 실행할 때 확인을 요구하지 않습니다. 

신중하게 DROP TABLE을 사용해 주세요 

- 테이블 행 삭제

DROP TABLE 명령은 데이터 베이스에서 테이블을 삭제합니다. 이때 테이블에 저장된 데이터도 함께 삭제됩니다. 한편 테이블 정의는 그대로 둔 채 데이터만 삭제할 때는 DELETE 명령을 사용합니다. 이때 DELETE 명령에 WHERE 조건을 지정하지 않으면 테이블의 모든 행을 삭제할 수 있습니다. 

하지만 DELETE 명령은 행 단위로 내부처리가 일어나므로 삭제할 행이 많으면 처리속도가 상당히 늦어집니다. 이런 경우에는 DDL로 분류되는 TRUNCATE TABLE  명령을 사용합니다. TRUNCATE TABLE 명령은 삭제할 행을 지정할 수 없고 WHERE 구를 지정할 수도 없지만, 모든 행을 삭제해야 할 때 빠른 속도로 삭제할 수 있습니다.

### ⭐️ 테이블 변경

테이블 작성한 뒤 열 구성은 언제든지 변경할 수 있습니다. 이때 테이블 변경은 ALTER TABLE 명령을 통해 이루어집니다. 

ALTER TABLE 명령을 사용하면 테이블에 저장되어 있는 데이터는 그대로 남긴 채 구성만 변경할 수 있습니다. ALTER TABLE로 할 수 있는 일은 크게 두 가지로 분류할 수 있습니다.

- 열추가, 삭제, 변경
- 제약 추가, 삭제

→ 열추가 

ALTER TABLE에서 열 추가할 때는 ADD 하부명령을 통해 실행할 수 있습니다. 

```sql
- 열추가 
ALTER TABLE 테이블명 ADD 열 정의

mysql> ALTER TABLE sample62 ADD newcol INTEGER;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC sample62;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| no     | int         | NO   |     | NULL    |       |
| a      | varchar(30) | YES  |     | NULL    |       |
| b      | date        | YES  |     | NULL    |       |
| newcol | int         | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
```

ALTER TABLE ADD로 열을 추가할 때, 기존 데이터행이 존해마녀 추가한 열의 값이 모두 NULL이 됩니다. 물론 기본값이 지정되어 있으면 기본값으로 데이터가 저장됩니다. 한편 NOT NULL 제약을 붙인 열을 추가하고 싶다면 먼저 NOT NULL로 제약을 건 뒤에 NULL 이외의 값으로 기본값을 지정할 필요가 있습니다. 

→ 열 속성 변경

ALTER TABLE로 열 속성을 변경할 경우에는 다음과 같이 MODIFY 하부명령을 실행합니다.

```sql
- 열 속성 변경
ALTER TABLE 테이블명 MODIFY 열 정의
```

```sql
- ALTER TABLE로 열 속성 변경하기
mysql> ALTER TABLE sample62 MODIFY newcol VARCHAR(20);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC sample62;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| no     | int         | NO   |     | NULL    |       |
| a      | varchar(30) | YES  |     | NULL    |       |
| b      | date        | YES  |     | NULL    |       |
| newcol | varchar(20) | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
```

기존의 데이터 행이 존재하는 경우, 속성 변경에 따라 데이터 역시 변환됩니다 .이때 만약 자료형이 변경되면 테이블에 들어간 데이터의 자료형 역시 바뀝니다. 다만 그 처리과정에서 에러가 발생하면 ALTER TABLE 명령은 실행되지 않습니다.

→ 열 이름 변경

ALTER TABLE로 열 이름을 변경할 때는 CHANGE 하부명령으로 시행할 수 있습니다.

```sql
- 열 이름 변경
ALTER TABLE 테이블명 CHANGE [기존 열 이름] [신규 열 정의]
```

열 이름을 변경할 때는 MODIFY가 아닌 CHANGE를 사용합니다.

```sql
- ALTER TABLE로 테이블에 열 이름 변경하기
mysql> ALTER TABLE sample62 CHANGE newcol c VARCHAR(20);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC sample62;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| no    | int         | NO   |     | NULL    |       |
| a     | varchar(30) | YES  |     | NULL    |       |
| b     | date        | YES  |     | NULL    |       |
| c     | varchar(20) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
```

→ 열삭제 

ALTER TABLE로 열을 삭제할 때는 DROP 하부명령을 사용합니다.

```sql
- 열 삭제
ALTER TABLE 테이블명 DROP 열명
```

```sql
- ALTER TABLE로 열 삭제하기
mysql> ALTER TABLE sample62 DROP c;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC sample62;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| no    | int         | NO   |     | NULL    |       |
| a     | varchar(30) | YES  |     | NULL    |       |
| b     | date        | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
```

### ⭐️ ALTER TABLE로 테이블 관리

- 최대길이 연장

대규모 데이터베이스에서는 데이터 크기가 매우 커지는 경향이 있습니다. 특히 행 개수가 많은 테이블에서는 데이터 하나의 크기를 최적화하는 것만으로도 저장 공간을 절약할 수 있습니다. 

이러한 경우 ALTER TABLE로 열의 자료형만 변경해 대응할 수 있습니다. 열의 자료형은 처음 CREATE TABLE을 실행 할 때 결정됩니다. 특히 문자열형의 경우 최대길이를 지정하는데, 이 최대길이를 ALTER TABLE로 늘릴 수 있습니다.

반대로 줄이기 위해서는 문제점이 있는데, 먼저 기존의 행에 존재하는 데이터의 길이보다 작게 지정할 수는 없습니다. 작게 지정하면 저장된 데이터의 일부가 잘려나가므로 에러가 발생합니다. 일반적으로 최대길이를 늘리는 경우는 많지만 줄이는 경우는 없습니다.

- 열 추가

테이블에 열을 추가하는 일은 자주 일어납니다. 시스템의 기능 확장 등 이유는 여러가지 있는데, 이때 사용하는 ALTER TABLE 명령으로는 ADD를 사용합니다. 

# 제약

CREATE TABLE로 테이블을 정의할 경우, 열 이외에 제약도 정의할 수 있었습니다. 그 중 하나가 바로 NOT NULL 제약입니다. NOT NULL 이외에도 다양한 제약이 있습니다.

### ⭐️테이블 작성시 제약 정의

제약은 테이블에 설정하는 것입니다. CREATE TABLE로 테이블을 작성할 때 제약을 같이 정의합니다. 물론 ALTER TABLE로 제약을 지정하거나 변경할 수 있습니다.

이때 NOT NULL 제약 등 하나의 열에 대해 설정하는 제약은 열을 정의할 때 지정합니다. 

```sql
- 테이블 열에 제약 정의하기
mysql> CREATE TABLE sample631 ( 
	a INTEGER NOT NULL, 
	b INTEGER NOT NULL UNIQUE, 
	c VARCHAR(30)
);
Query OK, 0 rows affected (0.10 sec)
```

a 열에는 NOT NULL 제약이 걸려있습니다. 

b 열에는 NOT NULL 제약과 UNIQUE 제약이 걸려있습니다. 

c 열에는 지정되어 있지 않습니다.

이처럼 열에 대해 정의하는 제약을 ‘열 제약’ 이라 부릅니다.

‘복수열에 의한 기본키 제약’ 처럼 한 개의 제약으로 복수의 열에 제약을 설명하는 경우를 ‘테이블 제약’이라 부릅니다.

```sql
- 테이블에 '테이블 제약' 정의하기
mysql> CREATE TABLE sample632( 
	no INTEGER NOT NULL, 
	sub_no INTEGER NOT NULL, 
	name VARCHAR(30), 
	PRIMARY KEY(no, sub_no)
);
Query OK, 0 rows affected (0.01 sec)
```

제약에는 이름을 붙일 수 있습니다. 제약에 이름을 붙이면 나중에 관리하기 쉬워지므로 가능한 한 이름을 붙이도록 합니다. 제약 이름은 CONSTRAINT 키워드를 사용해서 지정합니다.

```sql
- '테이블 제약'에 이름 붙이기
mysql> CREATE TABLE sample632( 
	no INTEGER NOT NULL, 
	sub_no INTEGER NOT NULL, 
	name VARCHAR(30), 
	CONSTRAINT pkey_sample PRIMARY KEY(no, sub_no));
```

### ⭐️제약 추가

기존 테이블에도 나중에 제약을 추가할 수 있습니다. 이때 열 제약과 테이블 제약은 조금 다른 방법으로 추가합니다. 

- 열 제약 추가

열 제약을 추가할 경우 ALTER TABLE로 열 정의를 변경할 수 있습니다. 기존 테이블을 변경할 경우에는 제약을 위반하는 데이터가 있는지 먼저 검사합니다. 

만약 c 열에 NULL 값이 존재한다면 ALTER TABLE 명령은 에러가 발생합니다. 

```sql
- C 열에 NOT NULL 제약 걸기
mysql> ALTER TABLE sample631 MODIFY c VARCHAR (30) NOT NULL;
Query OK, 0 rows affected (0.04 sec)
```

- 테이블 제약 추가

테이블 제약은 ALTER TABLE의 ADD 하부명령으로 추가할 수 있습니다. 
기본키는 테이블에 하나만 설정할 수 있습니다. 이미 기본키가 설정되어 있는 테이블에 추가로 기본키를 작성할 수는 없습니다. 또, 열 제약을 추가할 때와 마찬가지로 기존의 행을 검사해 추가할 제약을 위반하는 데이터가 있으면 에러가 발생합니다. 

```sql
- 기본키 제약 추가하기
ALTER TABLE sample631 ADD CONSTRAINT pkey_sample631 PRIMARY KEY(a);
```

### ⭐️ 제약 삭제

테이블 제약은 나중에 삭제할 수도 있습니다.  열 제약의 경우, 제약을 추가할 때와 동일하게 열 정의를 변경합니다.

```sql
- c 열의 NOT NULL 제약 없애기
ALTER TABLE sample631 MODIFY c VARCHAR(30);
```

테이블 제약은 ALTER TABLE의 DROP 하부명령으로 삭제할 수 있습니다.

```sql
- pkey_sample631 제약 삭제하기
ALTER TABLE sample631 DROP CONSTRAINT pkey_sample631;
```

단, 기본키는 테이블당 하나만 설정할 수 있기 때문에 제약명을 지정하지 않고도 삭제할 수 있습니다.

```sql
- 기본키 제약 삭제하기
ALTER TABLE sample631 DROP PRIMARY KEY;
```

### ⭐️ 기본키

CREATE TABLE, ALTER TABLE을 통해 제약의 정의, 추가, 삭제에 관해 알아 보겠습니다. NOT NULL 제약은 열제약이며, 기본키 제약이 테이블 제약이라는 것도 알았습니다.

다음은 기본키 제약의 개념에 관해 설명하겠습니다.

```sql
mysql> CREATE TABLE sample634( 
	p INTEGER NOT NULL, 
	a VARCHAR(30), 
	CONSTRAINT pkey_sample634 PRIMARY KEY(p)
);
```

열 p가 테이블의 기본키 입니다. 기본키로 지정할 열은 NOT NULL 제약이 설정되어 있어야 합니다.

데이터베이스에는 열쇠를 뜻하는 ‘키(KEY)’ 라는 단어가 자주 나옵니다. 기본키는 테이블의 행 한 개를 특정할 수 있는 검색키 입니다. 기본키 제약이 설정된 테이블에서는 기본키로 검색했을 때 복수의 행이 일치하는 데이터를 작성할 수 없습니다. 기본키로 설정된 열이 중복하는 데이터 값을 가지면 제약에 위반됩니다.

```sql
mysql> INSERT INTO sample634 VALUES(1, '첫째줄');
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO sample634 VALUES(2, '둘째줄');
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO sample634 VALUES(3, '셋째줄');
Query OK, 1 row affected (0.00 sec)

```

INSERT로 테이블에 세개의 행을 추가하였습니다. 이때 p 열의 값이 각각 1, 2, 3으로 중복하지 않습니다. 이후 이미 존재하는 값인 2로 행을 추가해 보겟습니다.

```sql
mysql> INSERT INTO sample634 VALUES(2, '넷째줄');
ERROR 1062 (23000): Duplicate entry '2' for key 'sample634.PRIMARY'
```

기본키 제약에 위반된다는 에러를 반환합니다.

마찬가지로 UPDATE 명령 역시 제약에 위반되므로 실행되지 않습니다.

이처럼 열을 기본키로 짖어해 유일한 값을 가지도록 하는 구조가 바로 기본키 제약 입니다. 행이 유일성을 필요로 한다는 다른 의미에서 ‘유일성 제약’이라 불리는 경우도 있습니다.

- 복수의 열로 기본키 구성하기

기본키 제약에는 이를 구성할 열 지정이 필요합니다. 이때 지정된 열은 NOT NULL 제약이 설정되어 있어야 합니다. 즉, 기본키로는 NULL 값이 허용되지 않습니다. 

또한 기본키를 구성하는 열은 복수라도 상관없습니다. 복수의 열을 기본키로 설정했을 경우, 키를 구성하는 모든 열을 사용해서 중복하는 값이 있는지 없는지를 검사합니다.

# 인덱스 구조

‘색인’이라고도 불리는 인덱스는 데이터베이스 객체 중 하나입니다.

### ⭐️인덱스

인덱스는 테이블에 붙여진 색인이라 할 수 있습니다. 인덱스의 역할은 검색속도의 향상입니다. 여기서 ‘검색’ 이란 SELECT 명령에 WHERE 구로 조건을 지정하고 그에 일치하는 행을 찾는 일련의 과정입니다.

인덱스의 구조는 목차나 색인과 비슷합니다. 목차나 색인에 제목, 키워드별 페이지 번호가 적혀있듯, 데이터베이스의 인덱스에는 검색 시에 쓰이는 키워드와 대응하는 데이터 행의 장소가 저장되어 있습니다.

인덱스는 테이블과는 별개로 독립된 데이터베이스 객체로 작성됩니다. 하지만 인덱스만으로는 아무런 의미가 없습니다. 목차밖에 없는 책은본 적이 없는 것처럼, 인덱스는 테이블에 의존하는 객체라 할 수 있습니다. 대부분의 데이터베이스에서는 테이블을 삭제하면 인덱스도 같이 삭제됩니다.

### ⭐️검색에 사용하는 알고리즘

대량의 데이터를 효율적으로 검색하는 방법에 관해서는 예전부터 여러 가지로 연구되어 왔습니다. 데이터 탐색이라든가 검색 알고리즘 등이 그에 해당합니다. 데이터베이스의 인덱스에 쓰이는 대표적인 검색 알고리즘으로는 ‘이진트리’가 있으며, 그 다음으로는 ‘해시’가 유명합니다.

- 풀 테이블 스캔(full table scan)

인덱스가 지정되지 않은 테이블을 검색할 때는 풀 테이블 스캔이라 불리는 검색방법을 사용합니다. 처리방법은 단순한데, 테이블에 저장된 모든 값을 처음부터 차례로 조사해나가는 것입니다. 

- 이진탐색(binary search)

차례로 나열된 집합에 대해 유효한 검색 방법으로 처음부터 순서대로 조사하는 것이 아닌 집합을 반으로 나누어 조사하는 방법입니다.
대량의 데이터를 검색할 때는 이진 탐색이 빠릅니다.

- 이진트리(binary tree)

이진 탐색은 고속으로 검색할 수 있는 탐색 방법이지만 데이터가 미리 정렬되어 있어야 합니다. 트리는 노드(node)라는 요소로 구성됩니다. 각 노드는 두 개의 가지로 나뉘고, 노드의 왼쪽 가지는 작은 값 오른쪽 가지는 큰 값으로 나뉘어져 있습니다. 두개의 가지로 분기하는 구조라서 ‘이진트리’라 불립니다.

### ⭐️유일성

이진트리의 구조를 살피다 보면, 같은 값을 가지는 노드가 여러 개 있을 때의 결과에 대한 의문이 생길 수 있습니다. 사실 이진 트리에서는 집합 내에 중복되는 값을 가질 수 없습니다. 즉, 노드의 가지는 큰 쪽과 작은 쪽의 두 가지로 나뉘며, 같은 값을 허용하기 위해서는 ‘같은’ 이라는 제 3의 가지를 가질 필요가 있습니다. 

하지만, 이진트리에서 ‘같은 값’을 가지는 노드를 여러개 만들 수 없다 라는 특성은 키에 대하여 유일성을 가지게 할 경우에만 유용합니다. 그래서 기본키 제약은 이진 트리로 인덱스를 작성하는 데이터베이스가 많습니다.

# 인덱스 작성과 삭제

```sql
- 인덱스 작성, 삭제
CREATE INDEX
DROP INDEX
```

인덱스는 데이터베이스  객체의 하나로 DDL을 사용해서 작성하거나 삭제합니다. 표준 SQL에서는 CREATE INDEX 명령은 없습니다. 

### ⭐️인덱스 작성

인덱스는 CREATE INDEX 명령으로 만듭니다. 인덱스에 이름을 붙여 관리하는데, 데이터베이스 객체가 될지 테이블의 열처럼 취급될지는 데이터베이스 제품에 따라 다릅니다.

인덱스를 작성할 때는 해당 인덱스가 어느 테이블의 어느 열에 관한 것인지 지정할 필요가 있습니다. 이때 열은 복수로도 지정할 수 있습니다. 

```sql
CREATE INDEX
CREATE INDEX 인덱스명 ON 테이블명 (열명1, 열명2 ...)
```

EX) `CREATE INDEX isample65 ON sample62(no);`

### ⭐️인덱스 삭제

인덱스는 DROP INDEX 명령으로 삭제합니다. DROP 할 때는 다른 객체와 동일하게 인덱스 이름만 지정하면 됩니다. 다만 테이블 내 객체로서 작성하는 경우에는 테이블 이름도 지정합니다.

```sql
- DROP INDEX(스키마 객체의 경우)
DROP INDEX 인덱스명

-DROP INDEX(테이블 내 객체의 경우)
DROP INDEX 인덱스명 ON 테이블명
```

인덱스는 테이블에 의존하는 객체입니다. DROP TABLE로 테이블을 삭제하면 테이블에 작성된 인덱스도 자동으로 삭제됩니다. 인덱스만 삭제하는 경우에는 DROP INDEX를 사용합니다.

EX) `DROP INDEX isample65 ON sample62;`

인덱스를 지정해두면 검색이 빨라집니다. 작성한 인덱스의 열을 WHERE 구로 지정하여 SELECT 명령으로 검색하면 처리속도가 향상됩니다. 한편, INSERT 명령의 경우에는 인덱스를 최신 상태로 갱신하는 처리가 늘어나므로 처리속도는 조금 떨어집니다.

### ⭐️EXPLAIN

인덱스 작성을 통해 쿼리의 성능 향상을 기대할 수 있습니다. 이때 실제로 인덱스를 사용해 검색하는지를 확인하려면 EXPLAIN 명령을 사용합니다. 

```sql
- EXPLAIN
EXPLAIN SQL 명령
```

EXPLAIN 명령의 문법은 간단합니다. EXPLAIN에 뒤이어 확인하고 싶은 SELECT 명령 등의 SQL 명령을 지정하면 됩니다. 다만 이 SQL 명령은 실제로는 실행되지 않습니다. 

EXPLAIN은 표준 SQL에는 존재하지 않는, 데이터베이스 제품 의존형 명령입니다. 

```sql
- EXPLAIN 으로 인덱스 사용 확인하기 1 (MySQL)
EXPLAIN SELECT *FROM sample62 WHERE a = 'a';
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | sample62 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
```

sample62의 a 열에는 isample65라는 인덱스가 작성되어 있습니다. EXPLAIN의 뒤를 잇는 SELECT 명령은 a 열의 값을 참조해 검색하므로 isample65을 사용해 검색합니다.

```sql
- EXPLAIN으로 인덱스 사용 확인하기 2 (MySQL)
mysql> EXPLAIN SELECT *FROM sample62 WHERE no > 10;
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | sample62 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
```

### ⭐️최적화

SELECT 명령을 실행할 때 인덱스의 사용 여부를 선택한다는 것을 알았습니다. 이는 데이터베이스 내부의 최적화에 의해 처리되는 부분입니다. 내부처리에서는 SELECT 명령을 실행하기에 앞서 실행계획을 세웁니다. 실행계획에서는 ‘인덱스’가 지정된 열이 WHERE 조건으로 지정되어 있으니 인덱스를 사용하자와 같은 처리가 이루어 집니다. EXPLAIN 명령은 이 실행계획을 확인하는 명령입니다.

실행계획에서는 인덱스의 유무뿐만 아니라 인덱스를 사용할 것인지 여부에 대해서도 데이터베이스 내부의 최적화 처리를 통해 판단합니다. 이때 판단 기준으로 인덱스의 품질도 고려합니다. 

# 뷰 작성과 삭제

```sql
-뷰의 작성 및 삭제
CREATE VIEW 뷰명 AS SELECT 명령
DROP VIEW 뷰명
```

### ⭐️뷰

데이터베이스 객체란 테이블이나 인덱스 등 데이터베이스 안에 정의하는 모든 것을 말합니다. 뷰 역시 데이터베이스 객체 중 하나입니다. 반면 SELECT 명령은 객체가 아닙니다. SELECT 명령에 이름을 지정할 수도 없고 데이터베이스에 등록되지도 않기 때문입니다. 

이처럼 본래 데이터베이스 객체로 등록할  수 없는 SELECT 명령을, 객체로서 이름을 붙여 관리할  수 있도록 한 것이 뷰입니다. SELECT 명령은 실행했을 때 테이블에 저장된 데이터를 결괏값으로 반환합니다. 따라서 뷰를 참조하면 그에 정의 된 SELECT 명령의 실행결과를 테이블처럼 사용할 수 있습니다.

실제업무에서는 WHERE 구로 조건을 지정하거나 GROUP BY 구로 집계하는 등 좀 더 복잡한 명령으로 이루어지는 경우가 많습니다. 이런 경우 서브쿼리 부분을 뷰로 대체하여 복잡한 SELECT 명령을 데이터베이스에 등록해 두었다가 나중에 간단히 실행할 수도 있습니다. 

- 가상 테이블

뷰는 테이블처럼 취급할 수 있지만 실체가 존재하지 않는다 라는 의미로 가상 테이블이라 불리기도 합니다. SELECT 명령으로 이루어지는 뷰는 테이블처럼 데이터를 쓰거나 지울 수 있는 공간을 가지지 않습니다. 이 때문에 테이블 처럼 취급할 수 있다고는 해도 ‘SELECT 명령에서만 사용’하는것을 권장합니다. 

### ⭐️뷰 작성과 삭제

뷰는 데이터베이스 객체이기 때문에 DDL로  작성하거나 삭제합니다. 작성할 때는 CREATE VIEW를 , 삭제할 때는 DROP VIEW를 사용합니다.

- 뷰의 작성

```sql
- CREATE VIEW
CREATE VIEW 뷰명 AS SELECT 명령
```

CREATE VIEW 다음에 뷰의 이름을 지정하고, AS로 SELECT 명령을 지정합니다. CREATE VIEW의 AS 키워드는 별명을 붙일 때 사용하는 AS와 달리 생략할 수 없습니다.

```sql
- 뷰 작성하기
mysql> CREATE VIEW sample_view_67 AS SELECT *FROM sample54;
Query OK, 0 rows affected (0.10 sec)

mysql> SELECT *FROM sample_view_67;
+------+------+
| no   | a    |
+------+------+
|    1 |  100 |
|    2 |  900 |
|    3 |   20 |
|    4 |   80 |
+------+------+
```

뷰는 필요에 따라 열을 지정할 수도 있는데, 이경우에는 이름 뒤에 괄호로 묶어 열을 나열합니다.

```sql
CREATE VIEW 뷰명 (열명1, 열명2, ... ) AS SELECT 명령
```

뷰의 열 지정을 생략한 경우에는 SELECT 명령의 SELECT 구에서 지정하는 열 정보가 수집되어 자동적으로 뷰의 열로 지정됩니다. 반대로 열을 지정한 경우에는 SELECT 명령의 SELECT 구에 지정된 열보다 우선됩니다. 다만 SELECT 명령의 SELECT 구와 같은 수의 열을 일일이 지정해야 하므로 SELECT 명령의 모든 열을 사용할 경우에는 열을 지정하지 않는 편이 낫습니다. 또한 열 이외에는 정의할 수 없으며, 테이블의 열을 정의할 때처럼 자료형이나 제약도 지정할 수 없습니다.

```sql
-열을 지정해 뷰 작성하기
mysql> CREATE VIEW sample_view_672(n,v,v2) AS SELECT no, a, a*2 FROM sample54;
Query OK, 0 rows affected (0.02 sec)

mysql> SELECT *FROM sample_view_672 WHERE n=1;
+------+------+------+
| n    | v    | v2   |
+------+------+------+
|    1 |  100 |  200 |
+------+------+------+
```

- 뷰 삭제

```sql
-DROP VIEW
DROP VIEW 뷰명
```

### ⭐️뷰의 약점

뷰는 데이터베이스 객체로서 저장장치에 저장됩니다. 하지만 테이블과 달리 대량의 저장공간을 필요로 하지 않습니다. 데이터베이스에 저장되는 것은 SELECT 명령 뿐이기 때문입니다. 다만 저장공간을 소비하지 않는 대신 CPU 자원을 사용합니다.

SELECT 명령은 데이터베이스의 테이블에서 행을 검색해 클라이언트로 반환하는 명령입니다.
검색 뿐만 아니라 ORDER BY로 정령하거나 GROUP BY로 정렬하거나 GROPU BY로 집계할 수 있습니다. 이러한 처리는 계산능력을 필요로 하기 때문에 컴퓨터의 CPU를 사용합니다.

뷰를 참조하면 뷰에 등록되어 있는 SELECT 명령이 실행됩니다. 실행 결과는 일시적으로 보존되며, 뷰를 참조할 때마다 SELECT 명령이 실행됩니다.

- 머티리얼라이즈드 뷰 (Materialized View)

뷰에도 약점은 있습니다. 뷰의 근원이 되는 테이블에 보관하는 데이터양이 많은경우, 집계처리를 할 때도 뷰가 사용된다면 처리속도가 많이 떨어질 수 밖에 없습니다. 뷰를 중첩해서 사용하는 경우에도 처리 속도가 떨어지기 쉽습니다.

이 같은 상황을 회피하기 위해 사용할 수 있는 것이 머티리얼라이즈드 뷰 입니다
일반적으로 뷰는 데이터를 일시적으로 저장했다가 쿼리가 실행 종료될 때 함께 삭제됩니다.
그에 비해 머티리얼라이즈드 뷰는 데이터를 일시적으로 저장해 사용하는 것이 아니라 테이블처럼 저장장치에 저장해두고 사용합니다.

머티리얼라이즈드 뷰는 처음 참조되었을 때 데이터를 저장해둡니다. 이후 다시 참조할 때 이전에 저장해 두었던 데이터를 그대로 사용합니다. 일반적인 뷰처럼 매번 SELECT 명령을 실행할 필요가 없습니다. 다만 뷰에 지정된 테이블의 데이터가 변경된 경우에는 SELECT 명령을 재실행하여 데이터를 다시 저장합니다.
이처럼 변경 유무를 확인하여 재실행하는 것은 RDBMS가 자동으로 실행합니다.

뷰에 지정된 테이블의 데이터가 자주 변경되지 않는 경우라면 머티리얼라이즈드 뷰를 사용하여 뷰의 약점을 어느정도 보완할 수 있습니다. 하지만 MySQL에서는 머티리얼라이즈드 뷰를 제공하지 않습니다..

- 함수 테이블

뷰는 또 하나의 약점을 가집니다. 뷰를 구성하는 SELECT 명령은 단독으로도 실행할 수 있어야합니다 상관 서브쿼리에서 언급한 것처럼 부모 쿼리와 어떤 식으로든 연관된 서브쿼리의 경우에는 뷰의 SELECT 명령을 사용할 수 없습니다. 대신 이같은 뷰의 약점을 함수 테이블을 사용해여 회피할 수 있습니다. 함수테이블은 테이블을 결괏값으로 반환해주는 사용자정의 함수입니다. 함수에는 인수를 지정할 수 있기 때문에 인수의 값에 따라 WHERE 조건을 붙여 결괏값을 바꿀 수 있습니다. 그에 따라 상관 서브쿼리처럼 동작할 수 있습니다.