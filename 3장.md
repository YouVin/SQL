# 정렬 - ORDER BY

### ⭐️ORDER BY로 검색 결과 정렬하기

SELECT 명령의 ORDER BY 구로 정렬하고 싶은 열을 지정합니다. 

```jsx
SELECT 열명 FROM 테이블명 WHERE 조건식 ORDER BY 열명
```

검색 조건이 필요없는 경우에는 WHERE 구를 생략하는데 이때 ORDER BY 구는 FROM 구의 뒤에 지정합니다.

```jsx
SELECT 열명 FROM 테이블명 ORDER BY 열명
```

```sql
mysql> SELECT *FROM sample31;
+------+------+-------------------+
| name | age  | address           |
+------+------+-------------------+
| A씨  |   36 | 대구광역시 중구   |
| B씨  |   18 | 부산광역시 연제구 |
| C씨  |   25 | 서울특별시 중구   |
+------+------+-------------------+
3 rows in set (0.01 sec)

mysql> SELECT *FROM sample31 ORDER BY age;
+------+------+-------------------+
| name | age  | address           |
+------+------+-------------------+
| B씨  |   18 | 부산광역시 연제구 |
| C씨  |   25 | 서울특별시 중구   |
| A씨  |   36 | 대구광역시 중구   |
+------+------+-------------------+
3 rows in set (0.00 sec)
```

위는 sample31 테이블를 age 열의 값을 오름차순으로 정렬합니다.

```sql
mysql> SELECT *FROM sample31 ORDER BY address;
+------+------+-------------------+
| name | age  | address           |
+------+------+-------------------+
| A씨  |   36 | 대구광역시 중구   |
| B씨  |   18 | 부산광역시 연제구 |
| C씨  |   25 | 서울특별시 중구   |
+------+------+-------------------+
3 rows in set (0.00 sec)
```

위는 address의 열로 정렬합니다.

### ⭐️ORDER BY DESC로 내림차순으로 정렬하기

```sql
SELECT 열명 FROM 테이블명 ORDER BY 열명 DESC
```

앞선 예제에서 아무것도 지정하지 않았는데 오름차순으로 정렬되었습니다. 오름차순은 생략 가능하며, ASC로도 지정할 수 있습니다.

```sql
SELECT 열명 FROM 테이블명 ORDER BY 열명 ASC
```

```sql
mysql> SELECT *FROM sample31 ORDER BY age DESC;
+------+------+-------------------+
| name | age  | address           |
+------+------+-------------------+
| A씨  |   36 | 대구광역시 중구   |
| C씨  |   25 | 서울특별시 중구   |
| B씨  |   18 | 부산광역시 연제구 |
+------+------+-------------------+
3 rows in set (0.00 sec)

mysql> SELECT *FROM sample31 ORDER BY age ASC;
+------+------+-------------------+
| name | age  | address           |
+------+------+-------------------+
| B씨  |   18 | 부산광역시 연제구 |
| C씨  |   25 | 서울특별시 중구   |
| A씨  |   36 | 대구광역시 중구   |
+------+------+-------------------+
3 rows in set (0.00 sec)
```

### ⭐️대소관계

ORDER BY로 정렬할 때는 값의 대소관계가 중요합니다. 수치형 데이터라면 대소관계는 숫자의 크기로 판별하므로 이해하기 쉽습니다.

날짜형 데이터 또한 숫자형과 마찬가지로 구분 됩니다. 

문자열형 데이터의 대소관계는 사전식 순서에 의해 결정됩니다.

문자열형 데이터를 비교할 때는 문자열 형으로 입력된 숫자들을 비교 시 사전식으로 정렬되기 때문에 원하는 답이 안나올 수 있습니다.

```sql
mysql> SELECT *FROM sample311;
+------+------+
| a    | b    |
+------+------+
| 1    |    1 |
| 2    |    2 |
| 10   |   10 |
| 11   |   11 |
+------+------+
4 rows in set (0.00 sec)

mysql> SELECT *FROM sample311 ORDER BY a;
+------+------+
| a    | b    |
+------+------+
| 1    |    1 |
| 10   |   10 |
| 11   |   11 |
| 2    |    2 |
+------+------+
4 rows in set (0.00 sec)
```

위는 a는 VARCHAR 형식안에 숫자가, b는 INTEGER 형식안에 숫자로 이루어져 a를 기준으로 정렬하면 사전식으로 인해 저런 식으로 됩니다.

### ⭐️ORDER BY는 테이블에 영향을 주지 않는다.

ORDER BY를 통해 행 순서를 바꿀 수 있습니다. 하지만 이는 어디까지나 서버에서 클라이언트로 행 순서를 바꾸어 결과를 반환하는 것뿐, 서버장치에 저장된 데이터의 행 순서를 변경하는 것은 아닙니다.

# 복수의 열을 지정해 정렬하기

### ⭐️복수 열로 정렬 지정

ORDER BY로 행을 정렬하는 경우 같은 값을 가진 행의 순서는 어떻게 정해지는 걸까요 ? 

- 순서는 일정하지 않다
- 정해진 순서로 결과를 얻고 싶다면 반드시 ORDER BY 구로 순서를 지정해야 합니다.

```sql
mysql> SELECT *FROM sample32;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    2 |    1 |
|    2 |    2 |
|    1 |    3 |
|    1 |    2 |
+------+------+
```

ORDER BY로 복수 열 지정하기

ORDER BY 구에는 복수로 열을 지정할 수 있습니다. SELECT 구에서 열을 지정한 것처럼 콤마( , )로 열명을 구분해 지정하면 됩니다.

```sql
SELECT 열명 FROM 테이블명 ORDER BY 열명1, 열명2
```

```sql
- a 열과 b 열로 정렬하기
mysql> SELECT *FROM sample32 ORDER BY a, b;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    1 |    2 |
|    1 |    3 |
|    2 |    1 |
|    2 |    2 |
+------+------+
```

ORDER BY 구에 복수의 열을 지정할 수 있다

```sql
- b 열과 a 열로 정렬하기
mysql> SELECT *FROM sample32 ORDER BY b, a;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    2 |    1 |
|    1 |    2 |
|    2 |    2 |
|    1 |    3 |
+------+------+
```

### ⭐️정렬방법 지정하기

복수 열을 지정한 경우에도 각 열에 대해 개별적으로 정렬방법을 지정할 수 있습니다. 이때는 각 열 뒤에 ASC나 DESC를 붙여줍니다.

```sql
SELECT 열명 FROM 테이블명 ORDER BY 열명1 [ASC|DESC], 열명2 [ASC|DESC]
```

```sql
- a 열은 오름차순으로, b 열은 내림차순으로 정렬하기
mysql> SELECT *FROM sample32 ORDER BY a ASC, b DESC;
+------+------+
| a    | b    |
+------+------+
|    1 |    3 |
|    1 |    2 |
|    1 |    1 |
|    2 |    2 |
|    2 |    1 |
+------+------+
```

### ⭐️NULL 값의 정렬순서

NULL 값이 저장된 열의 정렬방법을 살펴보겠습니다.

간단히 말하자면 ORDER BY로 지정한 열에서 NULL 값을 가지는 행은 가장 먼저 표시되거나 가장 나중에 표시됩니다.

NULL에 대한 대소비교 방법은 표준SQL에도 규정되어 있지 않아 데이터베이스 제품에 따라 기준이 다릅니다.

MySQL의 경우는 NULL 값을 가장 작은 값으로 취급해 ASC에서는 가장 먼저, DESC 에서는 가장 나중에 표시합니다.

# 결과 행 제한하기 - LIMIT

### ⭐️행수 제한

SELECT 명령에서는결괏값으로 반환되는 행을 제한할 수 있습니다.

```sql
SELECT 열명 FROM 테이블명 LIMIT 행수 [OFFSET 시작행]
```

LIMIT 구는 표준 SQL은 아닙니다. MySQL과 PostgreSQL에서 사용할 수 있는 문법이라는 점에 주의해 주세요.

```sql
SELECT 열명 FROM 테이블명 WHERE 조건식 ORDER BY 열명 LIMIT 행수
```

LIMIT 다음에는 최대 행수를 수치로 지정합니다. 만약 LIMIT 10으로 지정하면 최대 10개의 행이 클라이언트로 반환됩니다. 

```sql
mysql> SELECT *FROM sample33;
+------+
| no   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
|    6 |
|    7 |
+------+

- LIMIT 3으로 상위 3건만 취득하기
mysql> SELECT *FROM sample33 LIMIT 3;
+------+
| no   |
+------+
|    1 |
|    2 |
|    3 |
+------+
```

Point. LIMIT 구로 반환될 행수를 제한할 수 있다.

- 정렬한 후 제한하기

앞의 사례에서 LIMIT 3을 한 것과 동일한 결과를 얻기 위해 WHERE 구에 조건을 지정할 수 있습니다.

EX) WHERE no ≤ 3 과 같은 조건을 붙인다면 동일한 결과를 얻을 수 있습니다.

하지만 LIMIT 와 WHERE 은 기능과 내부처리 순서가 전혀 다릅니다. 

LIMIT은 반환할 행수를 제한하는 기능으로, WHERE 구는 검색한 후 ORDER BY로 정렬된 뒤 최종적으로 처리합니다.

```sql
- 정렬 후 LIMIT 3으로 상위 3건만 취득하기
mysql> SELECT *FROM sample33 ORDER BY no DESC LIMIT 3;
+------+
| no   |
+------+
|    7 |
|    6 |
|    5 |
+------+
```

- LIMIT을 사용할 수 없는 데이터베이스에서의 행 제한

SQL Server → SELECT TOP 3 *FROM sample33;

Oracle → SELECT *FROM sample33 WHERE ROWNUM ≤ 3;

### ⭐️오프셋 지정

오프셋은 보통 게시판이나 커뮤니티 사이트에서 하단 부분에 

‘1 2 3 4 5 다음’ 표시된 곳에서 사용됩니다.

이때 LIMIT과 OFFSET을 사용하여 구현이 가능합니다.

```sql
- LIMIT 3 OFFSET 0 으로 첫 번째 페이지 표시
mysql> SELECT *FROM sample33 LIMIT 3 OFFSET 0;
+------+
| no   |
+------+
|    1 |
|    2 |
|    3 |
+------+
```

이때 위치는 맨앞 인덱스 0부터 시작하여 다음 행 3자리를 얻기 위해서는 다음 OFFSET 위치를 3으로 표시해야 합니다.

```sql
mysql> SELECT *FROM sample33 LIMIT 3 OFFSET 3;
+------+
| no   |
+------+
|    4 |
|    5 |
|    6 |
+------+
```

# 수치연산

### ⭐️사칙 연산

산술연산자

| 연산자 | 연산 | 예 |
| --- | --- | --- |
| + | 덧셈 | 1+2 → 3 |
| - | 뺄셈 | 1-2 → -1 |
| * | 곱셈 | 1*2 → 2 |
| / | 나눗셈 | 1/2 → 0.5 |
| % | 나머지 | 1%2 → 1 |
- 연산자의 우선순위

| 우선순위 | 연산자 |
| --- | --- |
| 1 | */% |
| 2 | +- |

### ⭐️SELECT 구로 연산하기

```sql
SELECT 식1, 식2 ... FROM 테이블명
```

```sql
- 가격 x 수량으로 금액 계산하기
mysql> SELECT *FROM sample34;
+------+-------+----------+
| no   | price | quantity |
+------+-------+----------+
|    1 |   100 |       10 |
|    2 |   230 |       24 |
|    3 |  1980 |        1 |
+------+-------+----------+
mysql> SELECT *, price *quantity FROM sample34;
+------+-------+----------+-----------------+
| no   | price | quantity | price *quantity |
+------+-------+----------+-----------------+
|    1 |   100 |       10 |            1000 |
|    2 |   230 |       24 |            5520 |
|    3 |  1980 |        1 |            1980 |
+------+-------+----------+-----------------+
```

### ⭐️열의 별명

현재 계산 결과의 셀 제목이 너무 길어 보여 이를 바꿔보려고 합니다.

이때 별명을 붙이는데 해당 별명을 amount로 바꾸어 해보겠습니다.

```sql
- price * quantity 제목을 amount 별명으로 바꾸기
mysql> SELECT *, price * quantity AS amount FROM sample34;
+------+-------+----------+--------+
| no   | price | quantity | amount |
+------+-------+----------+--------+
|    1 |   100 |       10 |   1000 |
|    2 |   230 |       24 |   5520 |
|    3 |  1980 |        1 |   1980 |
+------+-------+----------+--------+
```

별명은 예약어 AS를 사용해 지정합니다. 

MySQL에서는 별명을 중복해서 지정해도 에러는 발생하지 않지만 다른곳에서는 에러가 발생할 수 있습니다.

이때 AS 키워드는 생략이 가능합니다.

별명을 한글로 지정하는 경우에는 더블쿼트로 둘러싸서 지정합니다.

```sql
SELECT price * quantity “금액” FROM sample34;
```

이때 이름을 지정하는 경우 숫자로 시작되지 않도록 한다!

### ⭐️WHERE 구에서 연산하기

```sql
- WHERE 구에서 계산, 검색하기
mysql> SELECT *,price *quantity AS amount FROM sample34;
+------+-------+----------+--------+
| no   | price | quantity | amount |
+------+-------+----------+--------+
|    1 |   100 |       10 |   1000 |
|    2 |   230 |       24 |   5520 |
|    3 |  1980 |        1 |   1980 |
+------+-------+----------+--------+
- WHERE 구에서 금액을 계산하고 2000원 이상인 행 검색하기
mysql> SELECT *,price *quantity AS amount FROM sample34 WHERE price * quantity >= 2000;
+------+-------+----------+--------+
| no   | price | quantity | amount |
+------+-------+----------+--------+
|    2 |   230 |       24 |   5520 |
+------+-------+----------+--------+
```

이때 별명인 amount를 사용해 WHERE 지정하여 사용한다면 amount라는 열은 존재하지 않는다는 에러가 발생합니다.

- WHERE 구와 SELECT 구의 내부처리 순서

WHERE 구에서의 행 선택, SELECT 구에서의 열 선택은 데이터베이스 서버 내부에서 WHERE 구 → SELECT 구의 순서로 처리됩니다. 

별명은 SELECT 구문을 내부 처리할 때 비로소 붙여집니다. 즉, WHERE 구의 처리는 SELECT 구보다 선행되므로 WHERE 구에서 사용한 별칭은 아직 내부적으로 지정되지 않아 에러가 발생합니다.

### ⭐️NULL 값의 연산

NULL 값을 이용해 ‘NULL + 1’ 과같은 연산을 하면 결과는 어떻게 될까요?

MySQL → NULL에 관한 모든 연산의 결과는 NULL이 됩니다.

### ⭐️ORDER BY 구에서 연산하기

ORDER BY 구에서도 연산할 수 있고 그 결괏값들을 정렬할 수 있습니다.

```sql
- ORDER BY 구에서 금액을 계산하고 내림차순으로 정렬하기
mysql> SELECT *, price * quantity AS "가격" FROM sample34 ORDER BY price * quantity DESC;
+------+-------+----------+------+
| no   | price | quantity | 가격 |
+------+-------+----------+------+
|    2 |   230 |       24 | 5520 |
|    3 |  1980 |        1 | 1980 |
|    1 |   100 |       10 | 1000 |
+------+-------+----------+------+
```

이때 ORDER BY 구에서는 별명을 사용하여 정렬이 가능하다!

```sql
mysql> SELECT *, price * quantity AS amount FROM sample34 ORDER BY amount DESC;
+------+-------+----------+--------+
| no   | price | quantity | amount |
+------+-------+----------+--------+
|    2 |   230 |       24 |   5520 |
|    3 |  1980 |        1 |   1980 |
|    1 |   100 |       10 |   1000 |
+------+-------+----------+--------+
```

### ⭐️함수

연산자 외에 함수를 사용해 연산할 수도 있습니다.

함수는 다음과 같이 표기합니다.

- 함수명 (인수1, 인수2 …)

EX ) MOD(10, 3) → 1 

### ⭐️ROUND 함수

소수점을 반올림하는 ROUND 함수를 사용해 봅시다.

```sql
mysql> SELECT amount, ROUND(amount) FROM sample341;
+---------+---------------+
| amount  | ROUND(amount) |
+---------+---------------+
| 5961.60 |          5962 |
| 2138.40 |          2138 |
| 1080.00 |          1080 |
+---------+---------------+
```

이때 전체를 다 반올림 하는게 아닌 자릿수를 지정해서 반올림 해봅시다.

- 반올림 자릿수 지정

```sql
mysql> SELECT amount, ROUND(amount, 1) FROM sample341;
+---------+------------------+
| amount  | ROUND(amount, 1) |
+---------+------------------+
| 5961.60 |           5961.6 |
| 2138.40 |           2138.4 |
| 1080.00 |           1080.0 |
+---------+------------------+
```

그렇다면 10이나 100의 자릿수를 반올림하는 방법은 뭘까요?

```sql
mysql> SELECT amount, ROUND(amount, -2) FROM sample341;
+---------+-------------------+
| amount  | ROUND(amount, -2) |
+---------+-------------------+
| 5961.60 |              6000 |
| 2138.40 |              2100 |
| 1080.00 |              1100 |
+---------+-------------------+
```

# 문자열 연산

### ⭐️문자열 결합

데이터에는 수치형 외에 문자열형도 있습니다.

‘ ABC’ || ‘1234’ → ‘ABC1234’

| 연산자/함수 | 연산 | 데이터베이스 |
| --- | --- | --- |
| + | 문자열 결합 | SQL Server |
| || | 문자열 결합 | Oracle, DB2, PostgreSQL |
| CONCAT | 문자열 결합 | MySQL |

+연산자, || 연산자, CONCAT 함수로 문자열을 결합할 수 있다.

```sql
- 문자열 결합
mysql> SELECT *FROM sample35;
+------+-------+----------+------+
| no   | price | quantity | unit |
+------+-------+----------+------+
|    1 |   100 |       10 | 개   |
|    2 |   230 |       24 | 통   |
|    3 |  1980 |        1 | 장   |
+------+-------+----------+------+
mysql> SELECT CONCAT(quantity, unit) FROM sample35;
+------------------------+
| CONCAT(quantity, unit) |
+------------------------+
| 10개                   |
| 24통                   |
| 1장                    |
+------------------------+
```

sample35의 unit 열은 문자열이고  quantity열은 INTEGER 형의 열입니다.

CONCAT 함수를 이용해 두 열을 결합하였습니다. 문자열 결합이지만 수치 데이터도 문제없이 연산할 수 있습니다. 단, 문자열로 결합한 결과는 문자열형이 됩니다.

### ⭐️SUBSTRING 함수

SUBSTRING 함수는 문자열의 일부분을 계산해서 반환해주는 함수입니다.

(앞 4자리(년) 추출)

EX  ) SUBSTRING(’20140125001’, 1, 4) → ‘2014’

(5째 자리부터 2자리(월) 추출)

EX ) SUBSTRING(’20140125001’, 5, 2) → ‘01’

### ⭐️TRIM 함수

TRIM 함수는 문자열의 앞뒤로 여분의 스페이스가 있을 경우 이를 제거해주는 함수로 문자열 도중에 존재하는 스페이스는 제거되지 않습니다.

(TRIM으로 스페이스 제거하기)

EX ) TRIM(’ABC   ‘) → ‘ABC’

### ⭐️CHARACTER_LENGTH 함수

CHARACTER_LENGTH 함수는 문자열의 길이를 계산해 돌려주는 함수입니다. VARCHAR 형의 문자열은 가변 길이이므로 길이가 서로 다릅니다.

CHARACTER_LENGTH 함수를 사용하면 문자열의 길이를 계산할 수 있습니다. 문자열의 길이는 문자 단위로 계산되어 수치로 반환됩니다. 

OCTET_LENGTH 함수는 문자열의 길이를 바이트 단위로 계산해 돌려주는 함수입니다.

- 문자세트

반각의 알파벳이나 숫자, 기호는 ‘ASCII 문자’라고 불립니다.

한글의 경우 ‘EUC-KR’, ‘UTF-8’ 등의 인코드 방식을 주로 사용합니다. 인코드 방식은 데이터베이스나 테이블을 정의할 때 변경할 수 있습니다.

이를 RDBMS에서는 ‘문자세트’ 라고 부릅니다.

이때 OCTET_LENGTH함수는 바이트 단위로 계산을 하는데 한글과 알파벳의 바이트 단위는 다르기에 유의해야 합니다.

| 문자세트 | 문자 수 | 바이트 수 |
| --- | --- | --- |
| EUC-KR  | 12 | 19 |
| UTF-8 | 12 | 26 |

EUC-KR에서 ASCII 문자는 1바이트, 한글은 2바이트의 용량을 가집니다.

UTF-8에서 ASCII 문자는 1바이트, 한글은 3바이트의 용량을 가집니다.

# 날짜 연산

### ⭐️ SQL에서의 날짜

날짜나 시간 데이터는 수치 데이터와 같이 사칙 연산을 할 수 있습니다.

날짜시간 데이터를 연산하면 결괏값으로 동일한 날짜시간 유형의 데이터를 반환하는 경우도 있으며 기간(간격)의 차를 나타내는 기간형(interval) 데이터를 반환하는 경우도 있습니다. 

- 시스템 날짜

표준 SQL에서는 ‘CURRENT_TIMESTAMP’라는 이름의 함수로 실행한 시간을 표시합니다.

```sql
mysql> SELECT CURRENT_TIMESTAMP;
+---------------------+
| CURRENT_TIMESTAMP   |
+---------------------+
| 2024-12-19 19:31:42 |
+---------------------+
```

- 날짜 서식

날짜 데이터를 데이터베이스에 저장할 경우  CURRENT_TIMESTAMP를 사용해 시스템 상의 날짜를 저장할 수 있습니다. 다만 임의의 날짜를 지정하고 싶을 경우에는 직접 날짜 데이터를 지정해야 합니다.

다양한 날짜 표기하는 방식이 다양한 가운데 대부분의 데이터베이스 제품은 날짜 데이터의 서식을 임의로 지정, 변환할 수 있는 함수를 지원합니다. 

### ⭐️날짜의 덧셈과 뺄셈

날짜시간형 데이터는 기간형 수치데이터와 덧셈 및 뺄셈을 할 수 있습니다. 날짜 시간형 데이터에 기간형 수치데이터를 더하거나 빼면 날짜시간형 데이터가 반환됩니다. 예를 들어 특정일로부터 1일 후를 계산하고 싶다면 a + 1 DAY  라는 식으로 계산할 수 있습니다. 1일 전이라면 a - 1 DAY로 하면 합니다.

```sql
- 오늘의 날짜 -> 2024-12-19
mysql> SELECT CURRENT_DATE + INTERVAL 1 DAY;
+-------------------------------+
| CURRENT_DATE + INTERVAL 1 DAY |
+-------------------------------+
| 2024-12-20                    |
+-------------------------------+
```

INTERVAL 1 DAY 는 ‘1일 후’ 라는 의미의 기간형 상수입니다.

기간형 상수의 기술방법은 데이터베이스마다 조금씩 다르며 세세한 부분까지 표준화가 이루어지지는 않았습니다.

- 날짜형 간의 뺄셈

날짜시간형 데이터 간에 뺄셈을 할 수 있습니다

MySQL에서는 DATEDIFF(’2014-02-28’,’2014-01-01’)로 계산할 수 있습니다.

```sql
mysql> SELECT DATEDIFF('2014-02-28','2014-01-01');
+-------------------------------------+
| DATEDIFF('2014-02-28','2014-01-01') |
+-------------------------------------+
|                                  58 |
+-------------------------------------+
```

# CASE 문으로 데이터 변환하기

### ⭐️CASE 문

```sql
- CASE 문
CASE WHEN 조건식1 THEN 식1
	[ WHEN 조건식2 THEN 식2 ...]
	[ ELSE 식3]
END
```

WHEN 절에는 참과 거짓을 반환하는 조건식을 기술합니다. 

해당 조건을 만족하여 참이 되는 경우는  THEN 절에 기술한 식이 처리됩니다. 이때 WHEN과 THEN을 한데 조합해 지정할 수 있습니다.

WHEN 절의 조건식을 차례로 평가해 나가다가 가장 먼저 조건을 만족한 WHEN 절과 대응하는 THEN 절 식의 처리결과를 CASE 문의 결괏값으로 반환합니다.

그 어떤 조건식도 만족하지 못한 경우에는 ELSE 절에 기술한 식이 채택됩니다 ELSE 절은 생략이 가능하며 생략 했을 경우 ‘ELSE NULL’로 간주됩니다.

```sql
- NULL 값을 0으로 변환하기
mysql> SELECT a FROM sample37;
+------+
| a    |
+------+
|    1 |
|    2 |
| NULL |
+------+

mysql> SELECT a, CASE WHEN a IS NULL THEN 0 ELSE a END "a(null=0)" FROM sample37;
+------+-----------+
| a    | a(null=0) |
+------+-----------+
|    1 |         1 |
|    2 |         2 |
| NULL |         0 |
+------+-----------+
```

a 열 값이 NULL일 때 WHEN a IS NULL은 참이 되므로 CASE 문은 THEN 절의 ‘0’을 반환합니다. NULL이 아닌 경우에는 ELSE 절의 ‘a’, 즉 a 열의 값을 반환합니다.

- COALESCE

사실 NULL을 반환하는 경우라면 COALESCE 함수를 사용하는 편이 더 쉽습니다.

앞의 SELECT 명령 예제를 COALESCE 함수를 사용해 구현하면 다음과 같습니다.

```sql
- a 가 NULL이 아니면 a값을 그대로 출력하고, 그렇지 않으면 0 출력
SELECT a, COALESCE(a,0) FROM sample37;
```

COALESCE 함수는 여러 개의 인수를 지정할 수 있습니다. 

주어진 인수 가운데 NULL이 아닌 값에 대해서는 가장 먼저 지정된 인수의 값을 반환합니다. 

### ⭐️또 하나의 CASE 문

수치 데이터를 보여지는 문자열 데이터로 표시해봅시다.

문자화하는 것을 ‘디코드’라 부르고 반대로 수치화하는 것을 ‘인코드’라 부릅니다.

```sql
WHEN a = 1 THEN '남자'
WHEN a = 2 THEN '여자'
```

- 검색 CASE

CASE WHEN 조건식 TEHN 식 …

```sql
- 검색 CASE로 성별 코드를 남자, 여자로 변환하기
SELECT a AS "코드",
CASE
	WHEN a = 1 THEN '남자'
	WHEN a = 2 THEN '여자'
	ELSE '미지정'
END AS "성별" FROM sample37;
```

- 단순 CASE

CASE 식 WHEN 식 THEN 식 …

```sql
- 단순 CASE로 성별 코드를 남자, 여자로 변환하기
SELECT a AS "코드",
CASE a
	WHEN 1 THEN '남자'
	WHEN 2 THEN '여자'
	ELSE '미지정'
END AS "성별" FROM sample37;
```

### ⭐️CASE를 사용할 경우 주의사항

- ELSE 생략

ELSE를 생략하면 ELSE NULL이 되는것에 주의합시다.

상정한 것 이외의 데이터가 들어오는 경우도 많습니다. 대응하는 WHEN이 하나도 없으면 ELSE 절이 사용됩니다.  이때 ELSE를 생략하면 상정한 것 이외의 데이터가 왔을 때 NULL이 반환됩니다. 따라서 ELSE를 생략하지 않고 지정하는 편이 낫습니다.

- WHEN에 NULL 지정하기

단순 CASE에서는 WHEN 뒤에 1개의 상수값을 지정하는 경우가 많을 것입니다. 

데이터가 NULL인 경우를 고려해 WHEN NULL THEN ‘데이터 없을’과 같이 지정해도 문법적으로는 문제가 없지만 정상적으로 처리되지 않습니다. 

```sql
- 단순 CASE 문에서 WHEN 절에 NULL 지정하기
CASE a
	WHEN 1 THEN '남자'
	WHEN 2 THEN '여자'
	WHEN NULL THEN '데이터 없음'
	ELSE '미지정'
END
```

처리 순선 

1. a = 1
2. a = 2
3. a = NULL

비교 연산자 = 로는 NULL 값과 같은지 아닌지를 비교할 수 없습니다.

따라서 a 열의 값이 NULL 이라 해도 a = NULL은 참이 되지 않습니다.

즉 ‘데이터 없음’ 대신 ‘미지정’이라는 결괏값이 나옵니다.

이때 NULL 값인지 아닌지를 판정하기 위해서는 IS NULL을 사용합니다.

다만 단순 CASE 문은 특성상 = 연산자로 비교하는 만큼, NULL 값인지를 판정하려면 검색 CASE 문을 사용해야 합니다.

```sql
- 검색 CASE 문으로 NULL 판정하기
CASE
	WHEN a = 1 THEN '남자'
	WHEN a = 2 THEN '여자'
	WHEN a IS NULL THEN '데이터 없음'
	ELSE '미지정'
END
```