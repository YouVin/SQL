# 집합 연산

### ⭐️SQL과 집합

집합이라 하면 AND와 OR를 설명할 때 등장했던 ‘벤 다이어그램’을 떠올리는 분이 많을 겁니다. 집합을 설명할 때는 이러한 벤 다이어그램을 이용하기도 합니다.

SELECT 명령을 실행하면 데이터베이스에 질의하며 그 결과 몇 개의 행이 반환 됩니다. 이때 반환된 결과 전체를 하나의 집합이라고 생각하면 됩니다.

### ⭐️UNION으로 합집합 구하기

집합의 연산에는 ‘합집합’이라는 것이 있습니다 이는 집합을 서로 더한 것을 말합니다.

예를 들어 A 집합에는 { 1, 2, 3} 세 개의 요소가 B 집합에는 {2, 10, 11} 이라는 세 개의 요소가 존재할 때, 이 중 2라는 숫자는 두 집합에 모두 포함 되어 있어 합집합에는 하나의 요소로 표시 됩니다.
따라서 A와 B 집합의 합집합은 { 1, 2, 3, 10, 11 } 이 됩니다.

- UNION

SQL에서는 SELECT 명령의 실행 결과를 하나의 집합으로 다룰 수 있습니다. 합집합을 계산할 경우에는 수학에서 사용하던 기호 대신 UNION 키워드를 사용합니다. 

```sql
mysql> SELECT *FROM sample71_a;
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
+------+

mysql> SELECT *FROM sample71_b;
+------+
| b    |
+------+
|    2 |
|   10 |
|   11 |
+------+

mysql> SELECT *FROM sample71_a UNION SELECT *FROM sample71_b;
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
|   10 |
|   11 |
+------+
```

한 번의 쿼리 실행으로 두 개의 SELECT 명령이 내부적으로 실행되는 형식 입니다. 이때 각 SELECT 명령의 실행결과를 합집합으로 계산하여 최종적으로 결과를 반환합니다.

UNION을 이용하면 여러 개의 SELECT 명령을 하나로 묶을 수 있습니다.
이때  각각의 SELECT 명령의 열의 내용은 서로 일치해야 합니다. 위에 예제처럼 두개의 열은 이름은 서로 다르지만 열 개수와 자료형이 서로 같기 때문에 일치한다고 말할 수 있습니다. 반면 열 구성이 서로 다른 집합은 UNION으로 묶을 수 없습니다.

여기서 전체 데이터를 반환하는 애스터리스크(*)를 쓰지 않고, 열을 따로 지정하여 각 SELECT 명령에서 집합의 요소가 될 데이터를 서로 맞춰주면 UNION으로 실행할 수 있는 쿼리가 됩니다. 

```sql
SELECT a FROM sample_71_a UNION SELECT b FROM sample_71_b;
```

- UNION을 사용할 때의 ORDER BY

UNION으로 SELECT 명령을 결합해 합집합을 구하는 경우, 각 SELECT 명령에 ORDER BY를 지정해 정렬할 수는 없습니다. ORDER BY를 지정할 때는 마지막 SELECT 명령에만 지정하도록 합니다.

```sql
EX
- 첫번째 SELECT 명령에 ORDER BY를 지정할 수 없다.
SELECT a FROM sample71_a ORDER BY a UNION SELECT b FROM sample71_b;

- 마지막의 SELECT 명령에 ORDER BY를 지정한다.
SELECT a FROM sample71_a UNION SELECT b FROM sample71_b ORDER BY b;
```

하지만 이 쿼리에서도 에러가 발생합니다. ORDER BY를 지정할 수 있다고 해도 마지막의 SELECT 명령의 결과만 정렬하는 것이 아니고 합집합의 결과를 정렬하는 것 이기 때문입니다. 이 때 두 개의 SELECT 명령에서 열 이름이 서로 일치한다면 문제가 없겠지만 앞서 예제에서처럼 반드시 그렇다는 보장이 없습니다. 이런 경우 서로 동일하게 별명을 붙여 정렬이 가능합니다.

```sql
SELECT a AS c FROM sample71_a UNION SELECT AS c b FROM sample71_b ORDER BY c;
```

- UNION ALL

UNIO은 합집합을 구하는 것이므로 두  개의 집합에서 겹치는 부분은 공통 요소가 됩니다. 예를 들어 앞에서 살펴본 두 개의 집합에서는 양쪽 모두 2개 포함되어 있었습니다. 그리고 이들을 합집합 하면 2는 하나만 존재합니다. 두 명령의 실행 결과에 DISTINCT를 걸어 중복을 제거한 것과 같다고 생각하면 이해하기 쉬울 겁니다. 수학에서 말하는 집합은 중복값이 존재하지 않는 것을 전제로 합니다. 그래서 UNION을 한 결과에도 중복값이 제거되어 있습니다.

하지만 경우에 따라서 중복을 제거하지 않고 2개의 SELECT 명령의 결과를 그냥 합치고 싶은 때도 있을 겁니다 이러한 경우에 UNION ALL을 사용합니다.

```sql
- UNION ALL을 사용하여 전체 집합 표시
mysql> SELECT *FROM sample71_a UNION ALL SELECT *FROM sample71_b;
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
|    2 |
|   10 |
|   11 |
+------+
```

UNION ALL 중복값을 처리할 필요가 없으니 성능이 UNION보다 빠릅니다.

### ⭐️교집합과 차집합

MySQL에서는 않지만 SQL를 이용해 교집합, 차집합도 구할 수 있습니다. 교집합은 INTERSECT를, 차집합은 EXCEPT를 사용합니다.

교집합이란 두 개의 집합이 겹치는 부분으로 공통 부분으로 불립니다, 앞서 예제에서 두 집합의 같은 요소인 2가 바로 교집합의 아이템이 됩니다.

차집합은 집합에서 다른쪽의 집합을 제거하고 남은 부분입니다. 계산 대상이 되는 두 개의 집합에 공통부분이 존재하지 않으면 차집합을 구해도 결과는 바뀌지 않습니다. 
또한 완전히 같은 집합끼리 차집합을 계산하면 아무런 요소도 존재하지 않은 공집합이 됩니다. 차집합의 결과가 공집합인지 아닌지에 따라 두 개의 합이 동일한지 아닌지를 알 수 있습니다.

# 테이블 결합

데이터베이스는 하나의 테이블에 많은 데이터를 저장하지 않고 몇 개의 테이블로 나누어 저장합니다. 이처럼 여러 개로 나뉜 데이터를 하나로 묶어 결과를 내는 방법이 테이블 결합입니다.

### ⭐️곱집합과 교차결합

곱집합은 합집합이나 교집합처럼 집합의 연산 방법 중 하나입니다. 두 개의 집합을 곱하는 연산 방법으로 ‘적집합’ 또는 ‘카티전곱’ 이라고도 불립니다. 특히 곱집합은 야구팀들의 대전표를 짜는 것과 비슷하다고 생각하면 이해하기 쉬울 겁니다.

ex 집합 X는 { A, B, C } 라는 요소를 가집니다. 집합 Y는 { 1, 2, 3 }이라는 세 개의 요소를 가집니다. 여기서 집합 X와 Y의 곱집합을 구하면 총 9개의 { A, 1} ~ { C, 4} 까지의 요소들이 나옵니다.

- 교차결합( Cross Join )

```sql
- 교차결합
SELECT *FROM 테이블명1, 테이블명2
```

```sql
- FROM구에 테이블 두 개를 지정해 곱집합 구하기
mysql> SELECT *FROM sample72_x,sample72_y;
+------+------+
| x    | y    |
+------+------+
| C    |    1 |
| B    |    1 |
| A    |    1 |
| C    |    2 |
| B    |    2 |
| A    |    2 |
| C    |    3 |
| B    |    3 |
| A    |    3 |
+------+------+
```

FROM 구에 복수의 테이블을 지정하면 교차결합을 합니다. 교차결합은 두 개의 테이블을 곱집합으로 계산합니다.

-UNION 연결과 결합 연결의 차이

앞서 UNION에서도 집합을 더해 새로 큰 집합을 만들어 계산할 수 있었습니다. 한편으로는 FROM 구에서 복수의 테이블을 결합할 때도 새로 큰 집합을 만들어 계산합니다. 두 가지 방식이 서로 비슷합니다만 확대 방향이 다릅니다. UNION으로 합집합을 구했을 경우에는 세로 방향으로 더해지게 됩니다. 한편 FROM 구로 테이블을 결합할 경우에는 가로 방향으로 더해지게 됩니다. 

### ⭐️내부결합

앞선 예제에서는 두 개 테이블을 사용했습니다만 세 개, 네 개로도 지정할 수 있습니다. 단 테이블 수가 많아지면 조합 수가 엄청하게 늘어나 집합이 거대해집니다. 이렇게 많은 테이블을 교차결합 하는 경우는 드뭅니다. 즉, 결합 방법으로는 교차결합보다 내부결합이 자주 사용됩니다.

다음 예제로 한번 확인해봅시다.

```sql
- 상품 테이블과 재고수 테이블을 교차결합하기
mysql> SELECT *FROM 상품, 재고수;
+----------+--------+----------+------+----------+----------+------------+--------+
| 상품코드 | 상품명 | 메이커명 | 가격 | 상품분류 | 상품코드 | 입고일     | 재고수 |
+----------+--------+----------+------+----------+----------+------------+--------+
| 0003     | 상품3  | 메이커3  | 1980 | 생활용품 | 0001     | 2014-01-03 |    200 |
| 0002     | 상품2  | 메이커2  |  200 | 식료품   | 0001     | 2014-01-03 |    200 |
| 0001     | 상품1  | 메이커1  |  100 | 식료품   | 0001     | 2014-01-03 |    200 |
| 0003     | 상품3  | 메이커3  | 1980 | 생활용품 | 0002     | 2014-02-10 |    500 |
| 0002     | 상품2  | 메이커2  |  200 | 식료품   | 0002     | 2014-02-10 |    500 |
| 0001     | 상품1  | 메이커1  |  100 | 식료품   | 0002     | 2014-02-10 |    500 |
| 0003     | 상품3  | 메이커3  | 1980 | 생활용품 | 0003     | 2014-02-14 |     10 |
| 0002     | 상품2  | 메이커2  |  200 | 식료품   | 0003     | 2014-02-14 |     10 |
| 0001     | 상품1  | 메이커1  |  100 | 식료품   | 0003     | 2014-02-14 |     10 |
+----------+--------+----------+------+----------+----------+------------+--------+
```

FROM 구에 테이블을 복수로 지정하면 곱집합으로 계산되어 총 9개로 나옵니다. 이렇게 만들어진 집합에서 원하는 데이터를 검색하기 위해 WHERE 구로 조건을 지정합니다. 먼저 상품코드가 같다는 조건이 필요합니다. 먼저 상품코드가 같다는 조건이 필요합니다.

열 이름이 ‘상품코드’로 서로 동일하므로 WHERE 구에 조건식을 지정할 때 테이블 이름도 같이 지정할 필요가 있습니다. 상품 테이블 상품코드 열은 ‘상품.상품코드’로, 재고수 테이블의 상품코드 열은 ‘재고수.상품코드’로 지정합니다. 

```sql
mysql> SELECT *FROM 상품, 재고수 WHERE 상품.상품코드 = 재고수.상품코드;
+----------+--------+----------+------+----------+----------+------------+--------+
| 상품코드 | 상품명 | 메이커명 | 가격 | 상품분류 | 상품코드 | 입고일     | 재고수 |
+----------+--------+----------+------+----------+----------+------------+--------+
| 0001     | 상품1  | 메이커1  |  100 | 식료품   | 0001     | 2014-01-03 |    200 |
| 0002     | 상품2  | 메이커2  |  200 | 식료품   | 0002     | 2014-02-10 |    500 |
| 0003     | 상품3  | 메이커3  | 1980 | 생활용품 | 0003     | 2014-02-14 |     10 |
+----------+--------+----------+------+----------+----------+------------+--------+
```

이렇게 교차결합으로 계산된 곱집합에서 원하는 조합을 검색하는 것을 ‘내부결합’ 이라 부릅니다.

다음으로는 상품분류가 ‘식료품’이라는 조건이 필요합니다. 이 조건을 WHERE 구에 추가해보겠습니다. 추가할 때는 기존 조건식과 상품분류의 조건식이 모두 참이여야 하므로 AND로 조건식을 연결합니다. 또한 상품명과 재고수만 반환하도록 SELECT 구에 열을 지정합니다.

```sql
mysql> SELECT 상품.상품명, 재고수.재고수 FROM 상품, 재고수 WHERE 상품.상품코드 = 재고수.상품 코드 AND 상품.상품분류 = '식료품';
+--------+--------+
| 상품명 | 재고수 |
+--------+--------+
| 상품1  |    200 |
| 상품2  |    500 |
+--------+--------+
```

WHERE 구에는 두 개의 조건식이 지정되어 있습니다. 첫 번째 조건식은 교차결합으로 계산된 곱집합에서 원하는 조합을 검색하는 것입니다. 두 번째 조건식은 결합 조건이 아닌 검색 조건입니다. 여기에서 첫 번째 조건식의 조건을 ‘결합조건’이라 부릅니다.

### ⭐️INNER JOIN으로 내부결합하기

- FROM 구에 테이블을 복수 지정해 가로 방향으로 테이블 을 결합할 수 있다.
- 교차결합을 하면 곱집합으로 계산된다.
- WHERE 조건을 지정해 곱집합에서 필요한 조합만 검색할 수 있다.

INNER JOIN 키워드를 사용한 결합방법이 일반적으로 통용됩니다. 지금부터 상품 테이블과 재고 수 테이블을 이용한 사례를 INNER JOIN을 활용해 바꾸어보겠습니다.

```sql
-INNER JOIN으로 바꾸기
mysql> SELECT 상품.상품명, 재고수.재고수 FROM 상품 INNER JOIN 재고수 ON 상품.상품코드 = 재고 수.상품코드 WHERE 상품.상품분류 = '식료품';
+--------+--------+
| 상품명 | 재고수 |
+--------+--------+
| 상품1  |    200 |
| 상품2  |    500 |
+--------+--------+
```

```sql
- 내부결합
SELECT *FROM 테이블명1 INNER JOIN 테이블명2 ON 결합조건
```

테이블과 테이블 사이에 ‘INNER JOIN’이라는 키워드를 넣어 사용합니다. 

### ⭐️내부결합을 활용한 데이터 관리

‘하나의 데이터는 한 군데에 저장한다’라는 룰에 따라 데이터 구조를 설계한다고 했을 때, 메이커코드와 메이커명을 가지는 메이커 테이블을 작성해 데이터를 관리해보겠습니다.

상품을 제조하는 메이커가 많이 있다고 해도 상품 수보다는 적겠지요. 이때 코드와 이름을 가지고 테이블로 분활해 관리하면 저장공간도 절약할 수 있습니다. 

메이커코드는 메이커를 나타내는 코드라는 의미에서 맨 앞 자를 ‘M’으로 하였습니다. 

```sql
CREATE TABLE 메이커 ( 
	메이커코드 CHAR(4) NOT NULL,
	메이커명 VARCHAR(30),
	PRIMARY KEY (메이커코드)
	);
	
mysql> SELECT *FROM 메이커;
+------------+----------+
| 메이커코드 | 메이커명 |
+------------+----------+
| M001       | 메이커1  |
| M002       | 메이커2  |
+------------+----------+
```

상품 테이블에서는 메이커명을 메이커코드로 변경해 둡니다. 

```sql
- 상품 테이블과 메이커 테이블을 내부결합하기
mysql> SELECT S.상품명, M.메이커명 
	FROM 상품2 S INNER JOIN 메이커 M 
	ON S.메이커코드 = M.메이커코드;
+--------+----------+
| 상품명 | 메이커명 |
+--------+----------+
| 상품1  | 메이커1  |
| 상품2  | 메이커1  |
| 상품3  | 메이커2  |
+--------+----------+
```

이번에는 테이블에 별명을 붙였습니다. SELECT 명령에서 복수의 테이블을 다룰 경우 어느 테이블의 열인지 정확하게 지정해야 합니다. 이때 테이블명을 매번 지정하는 것은 번거로운 일이므로 짧게 줄여 별명을 붙이는 경우가 많습니다.

상품 테이블의 메이커코드만을 살펴보면 중복하는 행이 있습니다.
기본키 제약은 상품코드에만 적용되어 있어 데이터상으로도 제약에 위반되지 않습니다. 반대로 메이커 테이블은 메이커코드에 기본키가 지정되어 있기 때문에 중복을 허용하지 않습니다. 메이커코드는 유일하게 하나씩만 존재하며 중복될 수 없습니다. 존재하지 않거나 혹은 하나만 존재합니다.

- 외부키

메이커 테이블의 메이커코드는 기본키입니다. 그에 비해 상품 테이블의 메이커코드는 ‘외부키’라 불리는 것으로, 다른 테이블의 기본키를 참조하는 열이 외부키가 됩니다.

- 자기결합(Self Join)

자기결합은 테이블에 별명을 붙일 수 있는 기능을 이용해 같은 테이블끼리 결합 하는 것을 말합니다. 특별히 명령어가 정해져 있는 것은 아닙니다. 

```sql
mysql> SELECT S1.상품명, S2.상품명 
	FROM 상품 S1 INNER JOIN 상품 S2 
	ON S1.상품코드 = S2.상품코드;
+--------+--------+
| 상품명 | 상품명 |
+--------+--------+
| 상품1  | 상품1  |
| 상품2  | 상품2  |
| 상품3  | 상품3  |
+--------+--------+
```

상품 테이블을 가로로 두 개 나열해 상품코드로 결합했습니다.
자기결합에서는 결합의 좌우가 같은 테이블이 되기 때문에 이를 구별하기 위해서 반드시 별명을 붙여야 합니다.

### ⭐️외부결합

결합 방법은 크게 내부결합과 외부결합의 두 가지로 구분됩니다. 

외부결합이라고 해도 교차결합으로 결합 조건을 지정하여 검색한다는 기본적인 사고 방식은 같습니다. 외부결합은 ‘어느 한 쪽에만 존재하는 데이터 행을 어떻게 다룰지’를 변경할 수 있는 결합 방법입니다.

```sql
- 내부결합에서는 상품코드가 0009인 상품이 제외된다.
mysql> SELECT 상품3.상품명, 재고수.재고수 
	FROM 상품3 INNER JOIN 재고수 
	ON 상품3.상품코드 = 재고수.상품코드 
	WHERE 상품3.상품분류 = '식료품';
+--------+--------+
| 상품명 | 재고수 |
+--------+--------+
| 상품1  |    200 |
| 상품2  |    500 |
+--------+--------+
```

내부결합에서는 0009상품이 제외되는데 이때는 외부결합을 사용하면 된다. 외부결합은 결합하는 테이블 중에 어느 쪽을 기준으로 할지 결정할 수 있습니다. 이번에는 상품 테이블을 기준으로 INNER JOIN 대신 LEFT JOIN을 사용해본다.

```sql
- 외부결합으로 상품코드 0009인 상품도 결과에 포함하기
mysql> SELECT 상품3.상품명, 재고수.재고수 
	FROM 상품3 LEFT JOIN 재고수 
	ON 상품3.상품코드 = 재고수.상품코드 
	WHERE 상품3.상품분류 = '식료품';
+----------+--------+
| 상품명   | 재고수 |
+----------+--------+
| 상품1    |    200 |
| 상품2    |    500 |
| 추가상품 |   NULL |
+----------+--------+
```

재고수 테이블에는 0009에 대한 데이터가 없으므로 값이 NULL로 표시된다.  이번 기준은 왼쪽으로 하여 LEFT를 썻지만 오른쪽으로 하여 RIGHT도 가능하다.

- 구식방법에서의 외부결합과 표준 SQL

MySQL은 비교적 최근에 나온 데이터베이스 입니다. 따라서 구식 방법을 이용해도 내부결합은 가능하지만 외부결합은 불가능 합니다.

# 관계형 모델

관계형 모델을 기반으로 작성된 데이터베이스가 ‘관계형 데이터베이스’ 라는 점.

### ⭐️관계형 모델

관계형 모델(Relational Model)의 기본적인 요소는 릴레이션(Relation)입니다. 이 릴레이션이라는 말 자체는 관계를 뜻하지만 관계형 모델에서는 약간 다른 의미를 가집니다.

결합에 관한 설명할 때 ‘일반적인 시스템의 데이터베이스에는 복수의 테이블이 있어 테이블 간의 관계가 중요’하다고 배운 바 있습니다. 관계형 모델의 릴레이션은 SQL에서 말하는 테이블에 해당됩니다.

관계형 모델의 릴레이션에는 몇 가지 ‘속성(attribute)’이 있습니다. 이 속성은 속성 이름과 형 이름으로 구성됩니다. 속성은 sql에서 말하는 열에 해당합니다. 그리고 SQL에서의 행은 관계형 모델에서 ‘튜플(tuple)’이라 불립니다.

관계형 모델은 데이터 구조에 관해 정의합니다. 릴레이션은 튜플의 집합이며, 릴레이션에 대한 연산이 집합의 대한 연산에 대응된다는 이론을 ‘관계대수’라고 합니다. 기본 규칙은 다음과 같습니다.

- 하나 이상의 관계를 바탕으로 연산한다.
- 연산한 결과, 반환되는 것 또한 관계이다.
- 연산을 중첩 구조로 실행해도 상관없다.

### ⭐️관계형 모델과 SQL

관계대수에서는 자주 사용될 것 같은 릴레이션의 연산 방법을 몇 가지 규정합니다.

- 합집합

합집합(union)은 릴레이션끼리의 덧셈을 말합니다. 

`SELECT *FROM A UNION SELECT *FROM B`

- 차집합

차집합(difference)은 릴레이션끼리의 뺄셈을 말합니다. 

`SELECT *FROM A EXCEPT SELECT *FROM B`

- 교집합

교집합(intersection)은 릴레이션끼리의 공통부분(교집합)을 말합니다.

`SELECT *FROM A INTERSECT SELECT *FROM B`

- 곱집합

곱집합(cartesian product)은 릴레이션끼리의 대전표를 조합하는 연산을 말합니다. SQL에서는 FROM 구에 복수의 테이블을 지정한 경우 곱집합으로 계산됩니다.

`SELECT *FROM A, B SELECT *FROM A CROSS JOIN B`

- 선택

선택(selection)은 튜플의 추출을 말합니다. 선택은 제한이라 불리기도 합니다. 튜플은 SQL에서 행을 말하기 때문에 WHERE 구에 조건을 지정해 테이터를 검색하는 것에 해당됩니다.

`SELECT *FROM A WHERE no < 3`

- 투영

투영(projection)은 속성의 추출을 말합니다. SQL에서 속성은 열을 말하기 때문에 SELECT 구에 결과로 반환할 열을 지정하는 것에 해당됩니다.

`SELECT a FROM A`

- 결합

결합(join)은 릴레이션끼리 교차결합해 계산된 곱집합에서 결합조건을 만족하는 튜플을 추출하는 연산입니다. 

`SELECT a FROM A INNER JOIN B ON [A.no](http://A.no) = B.no`